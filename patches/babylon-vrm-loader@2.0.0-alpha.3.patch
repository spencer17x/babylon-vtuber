diff --git a/dist/index.module.js b/dist/index.module.js
index 5e8d755beb09f8f763da5f10a53ee6810175beea..636b22368e8c133658f0fe030b93e1c7b6a4239b 100644
--- a/dist/index.module.js
+++ b/dist/index.module.js
@@ -1 +1 @@
-!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@babylonjs/core/Maths/math"),require("@babylonjs/core"),require("@babylonjs/core/Misc/decorators"),require("@babylonjs/core/Misc/smartArray"),require("@babylonjs/core/scene"),require("@babylonjs/core/Maths/math.vector"),require("@babylonjs/core/Maths/math.color"),require("@babylonjs/core/Buffers/buffer"),require("@babylonjs/core/Materials/imageProcessingConfiguration"),require("@babylonjs/core/Materials/material"),require("@babylonjs/core/Materials/pushMaterial"),require("@babylonjs/core/Materials/materialHelper"),require("@babylonjs/core/Engines/constants"),require("@babylonjs/core/Materials/effectFallbacks"),require("@babylonjs/core/Materials/effect"),require("@babylonjs/core/Materials/material.detailMapConfiguration"),require("@babylonjs/core/Materials/materialPluginEvent"),require("@babylonjs/core/Misc/iInspectable"),require("@babylonjs/core/sceneComponent"),require("@babylonjs/core/Materials/materialDefines"),require("@babylonjs/loaders/glTF/2.0"),require("@babylonjs/core/Engines/engine"),require("@babylonjs/core/Meshes/Builders/sphereBuilder"),require("@babylonjs/core/Materials/standardMaterial"),require("@babylonjs/core/Meshes/meshBuilder"),require("@babylonjs/core/Loading/sceneLoader"),require("@babylonjs/loaders/glTF/glTFFileLoader")):"function"==typeof define&&define.amd?define(["@babylonjs/core/Maths/math","@babylonjs/core","@babylonjs/core/Misc/decorators","@babylonjs/core/Misc/smartArray","@babylonjs/core/scene","@babylonjs/core/Maths/math.vector","@babylonjs/core/Maths/math.color","@babylonjs/core/Buffers/buffer","@babylonjs/core/Materials/imageProcessingConfiguration","@babylonjs/core/Materials/material","@babylonjs/core/Materials/pushMaterial","@babylonjs/core/Materials/materialHelper","@babylonjs/core/Engines/constants","@babylonjs/core/Materials/effectFallbacks","@babylonjs/core/Materials/effect","@babylonjs/core/Materials/material.detailMapConfiguration","@babylonjs/core/Materials/materialPluginEvent","@babylonjs/core/Misc/iInspectable","@babylonjs/core/sceneComponent","@babylonjs/core/Materials/materialDefines","@babylonjs/loaders/glTF/2.0","@babylonjs/core/Engines/engine","@babylonjs/core/Meshes/Builders/sphereBuilder","@babylonjs/core/Materials/standardMaterial","@babylonjs/core/Meshes/meshBuilder","@babylonjs/core/Loading/sceneLoader","@babylonjs/loaders/glTF/glTFFileLoader"],t):"object"==typeof exports?exports["babylon-vrm-loader"]=t(require("@babylonjs/core/Maths/math"),require("@babylonjs/core"),require("@babylonjs/core/Misc/decorators"),require("@babylonjs/core/Misc/smartArray"),require("@babylonjs/core/scene"),require("@babylonjs/core/Maths/math.vector"),require("@babylonjs/core/Maths/math.color"),require("@babylonjs/core/Buffers/buffer"),require("@babylonjs/core/Materials/imageProcessingConfiguration"),require("@babylonjs/core/Materials/material"),require("@babylonjs/core/Materials/pushMaterial"),require("@babylonjs/core/Materials/materialHelper"),require("@babylonjs/core/Engines/constants"),require("@babylonjs/core/Materials/effectFallbacks"),require("@babylonjs/core/Materials/effect"),require("@babylonjs/core/Materials/material.detailMapConfiguration"),require("@babylonjs/core/Materials/materialPluginEvent"),require("@babylonjs/core/Misc/iInspectable"),require("@babylonjs/core/sceneComponent"),require("@babylonjs/core/Materials/materialDefines"),require("@babylonjs/loaders/glTF/2.0"),require("@babylonjs/core/Engines/engine"),require("@babylonjs/core/Meshes/Builders/sphereBuilder"),require("@babylonjs/core/Materials/standardMaterial"),require("@babylonjs/core/Meshes/meshBuilder"),require("@babylonjs/core/Loading/sceneLoader"),require("@babylonjs/loaders/glTF/glTFFileLoader")):e["babylon-vrm-loader"]=t(e["@babylonjs/core/Maths/math"],e["@babylonjs/core"],e["@babylonjs/core/Misc/decorators"],e["@babylonjs/core/Misc/smartArray"],e["@babylonjs/core/scene"],e["@babylonjs/core/Maths/math.vector"],e["@babylonjs/core/Maths/math.color"],e["@babylonjs/core/Buffers/buffer"],e["@babylonjs/core/Materials/imageProcessingConfiguration"],e["@babylonjs/core/Materials/material"],e["@babylonjs/core/Materials/pushMaterial"],e["@babylonjs/core/Materials/materialHelper"],e["@babylonjs/core/Engines/constants"],e["@babylonjs/core/Materials/effectFallbacks"],e["@babylonjs/core/Materials/effect"],e["@babylonjs/core/Materials/material.detailMapConfiguration"],e["@babylonjs/core/Materials/materialPluginEvent"],e["@babylonjs/core/Misc/iInspectable"],e["@babylonjs/core/sceneComponent"],e["@babylonjs/core/Materials/materialDefines"],e["@babylonjs/loaders/glTF/2.0"],e["@babylonjs/core/Engines/engine"],e["@babylonjs/core/Meshes/Builders/sphereBuilder"],e["@babylonjs/core/Materials/standardMaterial"],e["@babylonjs/core/Meshes/meshBuilder"],e["@babylonjs/core/Loading/sceneLoader"],e["@babylonjs/loaders/glTF/glTFFileLoader"])}(self,((e,t,i,n,r,a,o,s,l,h,d,u,f,c,m,p,g,_,M,A,v,T,I,S,E,x,N)=>(()=>{var b={838:(e,t,i)=>{var n;self,n=(e,t,i,n,r,a,o,s,l,h,d,u,f,c,m,p,g,_)=>(()=>{"use strict";var M={908:e=>{e.exports=a},556:e=>{e.exports=d},272:e=>{e.exports=f},55:e=>{e.exports=u},677:e=>{e.exports=o},66:e=>{e.exports=s},824:e=>{e.exports=c},713:e=>{e.exports=_},221:e=>{e.exports=h},628:e=>{e.exports=m},721:e=>{e.exports=l},548:e=>{e.exports=r},694:e=>{e.exports=n},388:t=>{t.exports=e},812:e=>{e.exports=p},474:e=>{e.exports=t},538:e=>{e.exports=i},667:e=>{e.exports=g}},A={};function v(e){var t=A[e];if(void 0!==t)return t.exports;var i=A[e]={exports:{}};return M[e](i,i.exports,v),i.exports}v.d=(e,t)=>{for(var i in t)v.o(t,i)&&!v.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},v.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),v.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var T={};return(()=>{function e(e,t,i,n){var r,a=arguments.length,o=a<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,i,n);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(a<3?r(o):a>3?r(t,i,o):r(t,i))||o);return a>3&&o&&Object.defineProperty(t,i,o),o}v.r(T),v.d(T,{CullMode:()=>b,DebugMode:()=>E,MToonMaterial:()=>D,OutlineColorMode:()=>x,OutlineWidthMode:()=>N}),Object.create,Object.create;var t=v(388),i=v(474),n=v(538),r=v(694),a=v(548),o=v(908),s=v(677),l=v(66),h=v(721),d=v(221),u=v(556),f=v(55),c=v(272),m=v(824),p=v(628),g=v(812),_=v(667);class M{constructor(e,t){this.scene=e,this.material=t,this.name=`MToonOutline_${t.name}_${M.rendererId++}`,this.scene._addComponent(this),this._engine=this.scene.getEngine(),this._passIdForDrawWrapper=[];for(let e=0;e<1;++e)this._passIdForDrawWrapper[e]=this._engine.createRenderPassId(`Outline Renderer (${e})`)}register(){this.scene._afterRenderingMeshStage.registerStep(_.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)}rebuild(){}dispose(){for(let e=0;e<this._passIdForDrawWrapper.length;++e)this._engine.releaseRenderPassId(this._passIdForDrawWrapper[e])}render(e,t,i){i=null!=i?i:this._passIdForDrawWrapper[0];const n=this.scene,r=e.effect;if(!r||!r.isReady()||!this.scene.activeCamera)return;const a=e._getDrawWrapper(i,!0);if(!a)return;if(a.setEffect(r),!a.effect||!a.effect.isReady())return;const o=e.getMesh(),s=o._internalAbstractMeshDataInfo._actAsRegularMesh?o:null,l=e.getRenderingMesh(),h=s||l;n.activeCamera&&(this.material.applyOutlineCullMode(),this.material.enableOutlineRender(),this._engine.enableEffect(a),this.isHardwareInstancedRendering(e,t)||l._bind(e,r,this.material.fillMode),this.material._preBind(r),l._processRendering(h,e,r,this.material.fillMode,t,this.isHardwareInstancedRendering(e,t),((t,i,n)=>{n&&n.bindForSubMesh(i,h,e)}),this.material),this.material.restoreOutlineCullMode(),this.material.disaableOutlineRender())}_afterRenderingMesh(e,t,i){if(!this.willRender(t))return;const n=this._engine.cullBackFaces;this._engine.cullBackFaces=!1,this.render(t,i,this._passIdForDrawWrapper[0]),this._engine.cullBackFaces=n}isHardwareInstancedRendering(e,t){return!!this._engine.getCaps().instancedArrays&&null!==t.visibleInstances[e._id]&&void 0!==t.visibleInstances[e._id]&&e.getRenderingMesh().hasThinInstances}willRender(e){const t=e.getMaterial();return!(!t||"MToonMaterial"!==t.getClassName()||t.getOutlineRendererName()!==this.name)}}M.rendererId=0;var A=v(713);class I extends A.MaterialDefines{constructor(e){super(e),this.CUSTOMUSERLIGHTING=!0,this.MTOON_OUTLINE_WIDTH_WORLD=!1,this.MTOON_OUTLINE_WIDTH_SCREEN=!1,this.MTOON_OUTLINE_COLOR_FIXED=!1,this.MTOON_OUTLINE_COLOR_MIXED=!1,this.MTOON_DEBUG_NORMAL=!1,this.MTOON_DEBUG_LITSHADERRATE=!1,this.SHADE=!1,this.SHADEDIRECTUV=0,this.RECEIVE_SHADOW=!1,this.RECEIVE_SHADOWDIRECTUV=0,this.SHADING_GRADE=!1,this.SHADING_GRADEDIRECTUV=0,this.RIM=!1,this.RIMDIRECTUV=0,this.MATCAP=!1,this.MATCAPDIRECTUV=0,this.OUTLINE_WIDTH=!1,this.OUTLINE_WIDTHDIRECTUV=0,this.UV_ANIMATION_MASK=!1,this.UV_ANIMATION_MASKDIRECTUV=0,this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.DIFFUSE=!1,this.DIFFUSEDIRECTUV=0,this.BAKED_VERTEX_ANIMATION_TEXTURE=!1,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.BUMP=!1,this.BUMPDIRECTUV=0,this.PARALLAX=!1,this.PARALLAXOCCLUSION=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHAFROMDIFFUSE=!1,this.POINTSIZE=!1,this.FOG=!1,this.NORMAL=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.OBJECTSPACE_NORMALMAP=!1,this.LOGARITHMICDEPTH=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.NONUNIFORMSCALING=!1,this.PREMULTIPLYALPHA=!1,this.ALPHATEST_AFTERALLALPHACOMPUTATIONS=!1,this.ALPHABLEND=!0,this.PREPASS=!1,this.PREPASS_IRRADIANCE=!1,this.PREPASS_IRRADIANCE_INDEX=-1,this.PREPASS_ALBEDO_SQRT=!1,this.PREPASS_ALBEDO_SQRT_INDEX=-1,this.PREPASS_DEPTH=!1,this.PREPASS_DEPTH_INDEX=-1,this.PREPASS_NORMAL=!1,this.PREPASS_NORMAL_INDEX=-1,this.PREPASS_POSITION=!1,this.PREPASS_POSITION_INDEX=-1,this.PREPASS_VELOCITY=!1,this.PREPASS_VELOCITY_INDEX=-1,this.PREPASS_REFLECTIVITY=!1,this.PREPASS_REFLECTIVITY_INDEX=-1,this.SCENE_MRT_COUNT=0,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=!1,this.TONEMAPPING_ACES=!1,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.MULTIVIEW=!1,this.ORDER_INDEPENDENT_TRANSPARENCY=!1,this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!1,this.IS_REFLECTION_LINEAR=!1,this.IS_REFRACTION_LINEAR=!1,this.EXPOSURE=!1,this.FLIP_U=!1,this.FLIP_V=!1,this.rebuild()}setReflectionMode(e){throw new Error("This material cannot use `setReflectionMode`")}}const S={effect:null,subMesh:null};var E,x,N,b;!function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate"}(E||(E={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(x||(x={})),function(e){e[e.None=0]="None",e[e.WorldCorrdinates=1]="WorldCorrdinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}(N||(N={})),function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}(b||(b={}));class D extends h.PushMaterial{constructor(e,t){super(e,t),this._diffuseTexture=null,this.diffuseTexture=null,this._emissiveTexture=null,this.emissiveTexture=null,this._bumpTexture=null,this.bumpTexture=null,this._shadeTexture=null,this.shadeTexture=null,this._receiveShadowTexture=null,this.receiveShadowTexture=null,this._shadingGradeTexture=null,this.shadingGradeTexture=null,this._rimTexture=null,this.rimTexture=null,this._matCapTexture=null,this.matCapTexture=null,this._outlineWidthTexture=null,this.outlineWidthTexture=null,this._uvAnimationMaskTexture=null,this.uvAnimationMaskTexture=null,this.diffuseColor=new a.Color3(1,1,1),this.ambientColor=new a.Color3(0,0,0),this.emissiveColor=new a.Color3(0,0,0),this.shadeColor=new a.Color3(.97,.81,.86),this.rimColor=new a.Color3(0,0,0),this.outlineColor=new a.Color3(0,0,0),this.useEmissiveAsIllumination=!1,this.linkEmissiveWithDiffuse=!1,this.useReflectionOverAlpha=!1,this._disableLighting=!1,this.useObjectSpaceNormalMap=!1,this.useParallax=!1,this.useParallaxOcclusion=!1,this.specularSupported=!1,this.useLightmapAsShadowmap=!1,this.useVertexColor=!1,this.useBones=!0,this.useMorphTargets=!0,this.useVertexAlpha=!1,this.useBakedVertexAnimation=!1,this.alphaCutOff=.4,this._useAlphaFromDiffuseTexture=!0,this._maxSimultaneousLights=4,this._invertNormalMapX=!0,this._invertNormalMapY=!0,this._twoSidedLighting=!1,this._renderTargets=new i.SmartArray(16),this._worldViewProjectionMatrix=r.Matrix.Zero(),this._globalAmbientColor=new a.Color3(0,0,0),this._cacheHasRenderTargetTextures=!1,this._bumpScale=1,this._receiveShadowRate=1,this._shadingGradeRate=1,this._shadeShift=0,this._shadeToony=.9,this._lightColorAttenuation=0,this._indirectLightIntensity=.1,this._rimLightingMix=0,this._rimFresnelPower=1,this._rimLift=0,this._outlineWidth=.5,this._outlineScaledMaxDistance=1,this._outlineLightingMix=1,this._uvAnimationScrollX=0,this._uvAnimationScrollY=0,this._uvAnimationRotation=0,this._alphaTest=!1,this._alphaBlend=!1,this._debugMode=E.None,this.debugMode=E.None,this._outlineWidthMode=N.None,this.isOutline=0,this.outlineColorMode=x.MixedLighting,this._cullMode=b.Back,this._outlineCullMode=b.Front,this.outlineCullMode=b.Front,this.storedCullMode=b.Back,this.flipU=!1,this.flipV=!1,this.detailMap=new m.DetailMapConfiguration(this),this._attachImageProcessingConfiguration(null),this.getRenderTargetTextures=()=>(this._renderTargets.reset(),this._eventInfo.renderTargets=this._renderTargets,this._callbackPluginEventFillRenderTargetTextures(this._eventInfo),this._renderTargets),c.Effect.IncludesShadersStore.mtoonUboDeclaration||(c.Effect.IncludesShadersStore.mtoonUboDeclaration="// it will be replaced to UboDeclaration(WebGL2) or VertexDeclaration(WebGL1).\n\nlayout(std140, column_major) uniform;\n\nuniform Material\n{\n    // Color & Texture\n    vec4 vDiffuseColor;\n    vec2 vDiffuseInfos;\n    mat4 diffuseMatrix;\n    vec4 vEmissiveColor;\n    vec2 vEmissiveInfos;\n    mat4 emissiveMatrix;\n    vec3 vBumpInfos;\n    mat4 bumpMatrix;\n    vec3 vShadeColor;\n    vec2 vShadeInfos;\n    mat4 shadeMatrix;\n    vec2 vReceiveShadowInfos;\n    mat4 receiveShadowMatrix;\n    vec2 vShadingGradeInfos;\n    mat4 shadingGradeMatrix;\n    vec3 vRimColor;\n    vec2 vRimInfos;\n    mat4 rimMatrix;\n    vec2 vMatCapInfos;\n    mat4 matCapMatrix;\n    vec4 vOutlineColor;\n    vec2 vOutlineWidthInfos;\n    mat4 outlineWidthMatrix;\n    vec2 vUvAnimationMaskInfos;\n    mat4 uvAnimationMaskMatrix;\n\n    // babylon specific\n    vec2 vTangentSpaceParams;\n    float pointSize;\n\n    // MToon params\n    float shadingGradeRate;\n    float receiveShadowRate;\n    float shadeShift;\n    float shadeToony;\n    float lightColorAttenuation;\n    float indirectLightIntensity;\n    float rimLightingMix;\n    float rimFresnelPower;\n    float rimLift;\n    float outlineWidth;\n    float outlineScaledMaxDistance;\n    float outlineLightingMix;\n    float uvAnimationScrollX;\n    float uvAnimationScrollY;\n    float uvAnimationRotation;\n\n    vec3 vEyeUp;\n    float alphaCutOff;\n    vec3 vAmbientColor;\n    float aspect;\n    float isOutline;\n    vec4 time;\n};\n\n// babylon specific\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n",c.Effect.IncludesShadersStore.mtoonVertexDeclaration="// Uniforms\nuniform mat4 viewProjection;\nuniform mat4 view;\nuniform mat4 projection;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float isOutline;\nuniform float aspect;\n\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\nuniform mat4 shadeMatrix;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\nuniform mat4 receiveShadowMatrix;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\nuniform mat4 shadingGradeMatrix;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\nuniform mat4 rimMatrix;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\nuniform mat4 matCapMatrix;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\nuniform mat4 outlineWidthMatrix;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\nuniform mat4 uvAnimationMaskMatrix;\n#endif\n\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n",c.Effect.IncludesShadersStore.mtoonFragmentDeclaration="uniform vec4 vEyePosition;\n\n// Colors\nuniform vec4 vDiffuseColor;\nuniform vec3 vEmissiveColor;\nuniform vec3 vShadeColor;\nuniform vec3 vRimColor;\nuniform vec4 vOutlineColor;\nuniform vec3 vAmbientColor;\n\nuniform vec3 vEyeUp;\nuniform float aspect;\nuniform float alphaCutOff;\nuniform float visibility;\nuniform float isOutline;\nuniform vec4 time;\n\n// Samplers\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\n#endif\n\n// MToon params\nuniform float shadingGradeRate;\nuniform float receiveShadowRate;\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float uvAnimationScrollX;\nuniform float uvAnimationScrollY;\nuniform float uvAnimationRotation;\n",c.Effect.IncludesShadersStore.mtoonFragmentFunctions="\n/**\n* Compute Directional or Point light direction\n*/\nvec3 computeLightDirection(vec4 lightData) {\n    return normalize(mix(lightData.xyz - vPositionW, -lightData.xyz, lightData.w));\n}\n\n/**\n* Compute Spot Light direction\n*/\nvec3 computeSpotLightDirection(vec4 lightData) {\n    return normalize(lightData.xyz - vPositionW);\n}\n\n/**\n* Compute Hemispheric light direction\n*/\nvec3 computeHemisphericLightDirection(vec4 lightData, vec3 vNormal) {\n    return normalize(lightData.xyz);\n}\n\n/**\n* Compute MToon diffuse lighting\n*/\nvec4 computeMToonDiffuseLighting(vec3 worldView, vec3 worldNormal, vec2 mainUv, vec3 lightDirection, vec4 lightDiffuse, float shadowAttenuation) {\n    float _receiveShadow = receiveShadowRate;\n#ifdef RECEIVE_SHADOW\n    _receiveShadow = _receiveShadow * texture2D(receiveShadowSampler, mainUv).r * vReceiveShadowInfos.y;\n#endif\n\n    float _shadingGrade = 0.0;\n#ifdef SHADING_GRADE\n    _shadingGrade = 1.0 - texture2D(shadingGradeSampler, mainUv).r * vShadingGradeInfos.y;\n#endif\n    _shadingGrade = 1.0 - shadingGradeRate * _shadingGrade;\n\n    // Lighting\n    vec3 _lightColor = lightDiffuse.rgb * step(0.5, length(lightDirection)); // length(lightDir) is zero if directional light is disabled.\n    float _dotNL = dot(lightDirection, worldNormal);\n#ifdef MTOON_FORWARD_ADD\n    float _lightAttenuation = 1.0;\n#else\n    float _lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, _receiveShadow);\n#endif\n\n    // lighting intensity\n    float _lightIntensity = _dotNL;\n    _lightIntensity = _lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]\n    _lightIntensity = _lightIntensity * _lightAttenuation; // receive shadow\n    _lightIntensity = _lightIntensity * _shadingGrade; // darker\n    _lightIntensity = _lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\n    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]\n    float _maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);\n    float _minIntensityThreshold = shadeShift;\n    _lightIntensity = clamp((_lightIntensity - _minIntensityThreshold) / max(EPS_COL, (_maxIntensityThreshold - _minIntensityThreshold)), 0.0, 1.0);\n\n    // Albedo color\n    vec3 _shade = vShadeColor;\n#ifdef SHADE\n    _shade = _shade * texture2D(shadeSampler, mainUv).rgb * vShadeInfos.y;\n#endif\n\n    vec4 _lit = vDiffuseColor;\n#ifdef DIFFUSE\n    _lit = _lit * texture2D(diffuseSampler, mainUv) * vDiffuseInfos.y;\n#endif\n    vec3 _col = mix(_shade.rgb, _lit.rgb, _lightIntensity);\n\n    // Direct Light\n    vec3 _lighting = _lightColor;\n    _lighting = mix(_lighting, vec3(max(EPS_COL, max(_lighting.x, max(_lighting.y, _lighting.z)))), lightColorAttenuation); // color atten\n#ifdef MTOON_FORWARD_ADD\n    _lighting *= 0.5; // darken if additional light\n    _lighting *= min(0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert\n    _lighting *= shadowAttenuation; // darken if receiving shadow\n#else\n    // base light does not darken.\n#endif\n    _col *= _lighting;\n\n    // Indirect Light\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _toonedGI = vAmbientColor.rgb; // TODO: GI\n    vec3 _indirectLighting = mix(_toonedGI, vAmbientColor.rgb, indirectLightIntensity);\n    _indirectLighting = mix(_indirectLighting, vec3(max(EPS_COL, max(_indirectLighting.x, max(_indirectLighting.y, _indirectLighting.z)))), lightColorAttenuation); // color atten\n    _col += _indirectLighting * _lit.rgb;\n\n    _col = min(_col.rgb, _lit.rgb); // comment out if you want to PBR absolutely.\n#endif\n\n    // parametric rim lighting\n#ifdef MTOON_FORWARD_ADD\n    vec3 _staticRimLighting = vec3(0.0);\n    vec3 _mixedRimLighting = _lighting;\n#else\n    vec3 _staticRimLighting = vec3(1.0);\n    vec3 _mixedRimLighting = _lighting + _indirectLighting;\n#endif\n    vec3 _rimLighting = mix(_staticRimLighting, _mixedRimLighting, rimLightingMix);\n    vec3 _rimColor = vRimColor.rgb;\n#ifdef RIM\n    _rimColor = _rimColor * texture2D(rimSampler, vRimUV + mainUv).rgb * vRimInfos.y;\n#endif\n    vec3 _rim = pow(clamp(1.0 - dot(worldNormal, worldView) + rimLift, 0.0, 1.0), rimFresnelPower) * _rimColor.rgb;\n    _col += mix(_rim * _rimLighting, vec3(0.0), isOutline);\n\n    // additive matcap\n#ifdef MTOON_FORWARD_ADD\n#else\n#ifdef MATCAP\n    vec3 _worldViewUp = normalize(vEyeUp - worldView * dot(worldView, vEyeUp));\n    vec3 _worldViewRight = normalize(cross(worldView, _worldViewUp));\n    vec2 _matCapUv = vec2(dot(_worldViewRight, worldNormal), dot(_worldViewUp, worldNormal)) * 0.5 + 0.5;\n    // uv.y is reversed\n    _matCapUv.y = (1.0 - _matCapUv.y);\n    vec3 _matCapLighting = texture2D(matCapSampler, _matCapUv).rgb * vMatCapInfos.y;\n    _col += mix(_matCapLighting, vec3(0.0), isOutline);\n#endif\n#endif\n\n    // Emission\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _emission = vEmissiveColor.rgb;\n#ifdef EMISSIVE\n    _emission *= texture2D(emissiveSampler, mainUv).rgb * vEmissiveInfos.y;\n#endif\n    _col += mix(_emission, vec3(0.0), isOutline);\n#endif\n\n    float _alpha = 1.0;\n\n#if defined(ALPHABLEND) || defined(ALPHATEST)\n    _alpha = mix(_lit.a, _lit.a * vOutlineColor.a, isOutline);\n#endif\n\n    // outline\n#ifdef MTOON_OUTLINE_COLOR_FIXED\n    _col = mix(_col, vOutlineColor.rgb, isOutline);\n#elif defined(MTOON_OUTLINE_COLOR_MIXED)\n    _col = mix(_col, vOutlineColor.rgb * mix(vec3(1.0), _col, outlineLightingMix), isOutline);\n#else\n#endif\n\n    // debug\n#ifdef MTOON_DEBUG_NORMAL\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(worldNormal * 0.5 + 0.5, _lit.a);\n    #endif\n#elif defined(MTOON_DEBUG_LITSHADERATE)\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(_lightIntensity, _lit.a);\n    #endif\n#endif\n\n    return vec4(_col, _alpha);\n}\n",c.Effect.IncludesShadersStore.mtoonLightFragment="#ifdef LIGHT{X}\n    #if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n        //No light calculation\n    #else\n        #ifdef PBR\n            // Compute Pre Lighting infos\n            #ifdef SPOTLIGHT{X}\n                preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(POINTLIGHT{X})\n                preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(HEMILIGHT{X})\n                preInfo = computeHemisphericPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(DIRLIGHT{X})\n                preInfo = computeDirectionalPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #endif\n\n            preInfo.NdotV = NdotV;\n\n            // Compute Attenuation infos\n            #ifdef SPOTLIGHT{X}\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w);\n                #else\n                    preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n                    preInfo.attenuation *= computeDirectionalLightFalloff(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n                #endif\n            #elif defined(POINTLIGHT{X})\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n                #else\n                    preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n                #endif\n            #else\n                preInfo.attenuation = 1.0;\n            #endif\n\n            // Simulates Light radius for diffuse and spec term\n            // clear coat is using a dedicated roughness\n            #ifdef HEMILIGHT{X}\n                preInfo.roughness = roughness;\n            #else\n                preInfo.roughness = adjustRoughnessFromLightProperties(roughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n            #endif\n\n            // Diffuse contribution\n            #ifdef HEMILIGHT{X}\n                info.diffuse = computeHemisphericDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb, light{X}.vLightGround);\n            #elif defined(SS_TRANSLUCENCY)\n                info.diffuse = computeDiffuseAndTransmittedLighting(preInfo, light{X}.vLightDiffuse.rgb, subSurfaceOut.transmittance);\n            #else\n                info.diffuse = computeDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb);\n            #endif\n\n            // Specular contribution\n            #ifdef SPECULARTERM\n                #ifdef ANISOTROPIC\n                    info.specular = computeAnisotropicSpecularLighting(preInfo, viewDirectionW, normalW, anisotropicOut.anisotropicTangent, anisotropicOut.anisotropicBitangent, anisotropicOut.anisotropy, clearcoatOut.specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n                #else\n                    info.specular = computeSpecularLighting(preInfo, normalW, clearcoatOut.specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n                #endif\n            #endif\n\n            // Sheen contribution\n            #ifdef SHEEN\n                #ifdef SHEEN_LINKWITHALBEDO\n                    // BE Carefull: Sheen intensity is replacing the roughness value.\n                    preInfo.roughness = sheenOut.sheenIntensity;\n                #else\n                    #ifdef HEMILIGHT{X}\n                        preInfo.roughness = sheenOut.sheenRoughness;\n                    #else\n                        preInfo.roughness = adjustRoughnessFromLightProperties(sheenOut.sheenRoughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n                    #endif\n                #endif\n                info.sheen = computeSheenLighting(preInfo, normalW, sheenOut.sheenColor, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n            #endif\n\n            // Clear Coat contribution\n            #ifdef CLEARCOAT\n                // Simulates Light radius\n                #ifdef HEMILIGHT{X}\n                    preInfo.roughness = clearcoatOut.clearCoatRoughness;\n                #else\n                    preInfo.roughness = adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n                #endif\n\n                info.clearCoat = computeClearCoatLighting(preInfo, clearcoatOut.clearCoatNormalW, clearcoatOut.clearCoatAARoughnessFactors.x, clearcoatOut.clearCoatIntensity, light{X}.vLightDiffuse.rgb);\n\n                #ifdef CLEARCOAT_TINT\n                    // Absorption\n                    absorption = computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract, preInfo.L, clearcoatOut.clearCoatNormalW, clearcoatOut.clearCoatColor, clearcoatOut.clearCoatThickness, clearcoatOut.clearCoatIntensity);\n                    info.diffuse *= absorption;\n                    #ifdef SPECULARTERM\n                        info.specular *= absorption;\n                    #endif\n                #endif\n\n                // Apply energy conservation on diffuse and specular term.\n                info.diffuse *= info.clearCoat.w;\n                #ifdef SPECULARTERM\n                    info.specular *= info.clearCoat.w;\n                #endif\n                #ifdef SHEEN\n                    info.sheen *= info.clearCoat.w;\n                #endif\n            #endif\n        #else\n            #ifdef SPOTLIGHT{X}\n                info = computeSpotLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDirection, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightDiffuse.a, glossiness);\n            #elif defined(HEMILIGHT{X})\n                info = computeHemisphericLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightGround, glossiness);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                info = computeLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightDiffuse.a, glossiness);\n            #endif\n        #endif\n\n        #ifdef PROJECTEDLIGHTTEXTURE{X}\n            info.diffuse *= computeProjectionTextureDiffuseLighting(projectionLightSampler{X}, textureProjectionMatrix{X});\n        #endif\n    #endif\n\n    #ifdef SHADOW{X}\n        #ifdef SHADOWCSM{X}\n            for (int i = 0; i < SHADOWCSMNUM_CASCADES{X}; i++)\n            {\n                #ifdef SHADOWCSM_RIGHTHANDED{X}\n                    diff{X} = viewFrustumZ{X}[i] + vPositionFromCamera{X}.z;\n                #else\n                    diff{X} = viewFrustumZ{X}[i] - vPositionFromCamera{X}.z;\n                #endif\n                if (diff{X} >= 0.) {\n                    index{X} = i;\n                    break;\n                }\n            }\n\n            #ifdef SHADOWCSMUSESHADOWMAXZ{X}\n            if (index{X} >= 0)\n            #endif\n            {\n                #if defined(SHADOWPCF{X})\n                    #if defined(SHADOWLOWQUALITY{X})\n                        shadow = computeShadowWithCSMPCF1(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #elif defined(SHADOWMEDIUMQUALITY{X})\n                        shadow = computeShadowWithCSMPCF3(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #else\n                        shadow = computeShadowWithCSMPCF5(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #endif\n                #elif defined(SHADOWPCSS{X})\n                    #if defined(SHADOWLOWQUALITY{X})\n                        shadow = computeShadowWithCSMPCSS16(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #elif defined(SHADOWMEDIUMQUALITY{X})\n                        shadow = computeShadowWithCSMPCSS32(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #else\n                        shadow = computeShadowWithCSMPCSS64(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #endif\n                #else\n                    shadow = computeShadowCSM(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                #endif\n\n                #ifdef SHADOWCSMDEBUG{X}\n                    shadowDebug{X} = vec3(shadow) * vCascadeColorsMultiplier{X}[index{X}];\n                #endif\n\n                #ifndef SHADOWCSMNOBLEND{X}\n                    float frustumLength = frustumLengths{X}[index{X}];\n                    float diffRatio = clamp(diff{X} / frustumLength, 0., 1.) * cascadeBlendFactor{X};\n                    if (index{X} < (SHADOWCSMNUM_CASCADES{X} - 1) && diffRatio < 1.)\n                    {\n                        index{X} += 1;\n                        float nextShadow = 0.;\n                        #if defined(SHADOWPCF{X})\n                            #if defined(SHADOWLOWQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCF1(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #elif defined(SHADOWMEDIUMQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCF3(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #else\n                                nextShadow = computeShadowWithCSMPCF5(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #endif\n                        #elif defined(SHADOWPCSS{X})\n                            #if defined(SHADOWLOWQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCSS16(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #elif defined(SHADOWMEDIUMQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCSS32(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #else\n                                nextShadow = computeShadowWithCSMPCSS64(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #endif\n                        #else\n                            nextShadow = computeShadowCSM(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                        #endif\n\n                        shadow = mix(nextShadow, shadow, diffRatio);\n                        #ifdef SHADOWCSMDEBUG{X}\n                            shadowDebug{X} = mix(vec3(nextShadow) * vCascadeColorsMultiplier{X}[index{X}], shadowDebug{X}, diffRatio);\n                        #endif\n                    }\n                #endif\n            }\n        #elif defined(SHADOWCLOSEESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPOISSON{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCF{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCSS{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #else\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #endif\n\n        #ifdef SHADOWONLY\n            #ifndef SHADOWINUSE\n                #define SHADOWINUSE\n            #endif\n            globalShadow += shadow;\n            shadowLightCount += 1.0;\n        #endif\n    #else\n        shadow = 1.;\n    #endif\n\n    #ifndef SHADOWONLY\n        #ifdef CUSTOMUSERLIGHTING\n            // Compute and reflect MToon lighting\n            #ifdef SPOTLIGHT{X}\n                lightDirection = computeSpotLightDirection(light{X}.vLightData);\n            #elif defined(HEMILIGHT{X})\n                lightDirection = computeHemisphericLightDirection(light{X}.vLightData, normalW.xyz);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                lightDirection = computeLightDirection(light{X}.vLightData);\n            #endif\n            mtoonDiffuse = computeMToonDiffuseLighting(viewDirectionW.xyz, normalW.xyz, mainUv, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\n            diffuseBase += mtoonDiffuse.rgb;\n            alpha = min(alpha, mtoonDiffuse.a);\n            #if defined(ALPHATEST) && ALPHATEST\n                alpha = (alpha - alphaCutOff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage\n                if (alpha < alphaCutOff) {\n                    discard;\n                }\n                alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity\n            #else\n                if (alpha - 0.0001 < 0.000) { // Slightly improves rendering with layered transparency\n                    discard;\n                }\n            #endif\n        #elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\n            diffuseBase += lightmapColor.rgb * shadow;\n            #ifdef SPECULARTERM\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    specularBase += info.specular * shadow * lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef CLEARCOAT\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    clearCoatBase += info.clearCoat.rgb * shadow * lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef SHEEN\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    sheenBase += info.sheen.rgb * shadow;\n                #endif\n            #endif\n        #else\n            #ifdef SHADOWCSMDEBUG{X}\n                diffuseBase += info.diffuse * shadowDebug{X};\n            #else\n                diffuseBase += info.diffuse * shadow;\n            #endif\n            #ifdef SPECULARTERM\n                specularBase += info.specular * shadow;\n            #endif\n            #ifdef CLEARCOAT\n                clearCoatBase += info.clearCoat.rgb * shadow;\n            #endif\n            #ifdef SHEEN\n                sheenBase += info.sheen.rgb * shadow;\n            #endif\n        #endif\n    #endif\n#endif\n",c.Effect.IncludesShadersStore.mtoonBumpFragment="// replace vBumpUV to mainUv\nvec2 uvOffset = vec2(0.0, 0.0);\n\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n    #ifdef NORMALXYSCALE\n        float normalScale = 1.0;\n    #elif defined(BUMP)\n        float normalScale = vBumpInfos.y;\n    #else\n        float normalScale = 1.0;\n    #endif\n\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #elif defined(BUMP)\n        // vec2 TBNUV = gl_FrontFacing ? vBumpUV : -vBumpUV;\n        vec2 TBNUV = gl_FrontFacing ? mainUv : -mainUv;\n        mat3 TBN = cotangent_frame(normalW * normalScale, vPositionW, TBNUV, vTangentSpaceParams);\n    #else\n        vec2 TBNUV = gl_FrontFacing ? vDetailUV : -vDetailUV;\n        mat3 TBN = cotangent_frame(normalW * normalScale, vPositionW, TBNUV, vec2(1., 1.));\n    #endif\n#elif defined(ANISOTROPIC)\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #else\n        // flip the uv for the backface\n        vec2 TBNUV = gl_FrontFacing ? vMainUV1 : -vMainUV1;\n        mat3 TBN = cotangent_frame(normalW, vPositionW, TBNUV, vec2(1., 1.));\n    #endif\n#endif\n\n#ifdef PARALLAX\n    mat3 invTBN = transposeMat3(TBN);\n\n    #ifdef PARALLAXOCCLUSION\n        // uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, vBumpUV, vBumpInfos.z);\n        uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, mainUv, vBumpInfos.z);\n    #else\n        uvOffset = parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z);\n    #endif\n#endif\n\n#ifdef DETAIL\n    vec4 detailColor = texture2D(detailSampler, vDetailUV + uvOffset);\n    vec2 detailNormalRG = detailColor.wy * 2.0 - 1.0;\n    float detailNormalB = sqrt(1. - saturate(dot(detailNormalRG, detailNormalRG)));\n    vec3 detailNormal = vec3(detailNormalRG, detailNormalB);\n#endif\n\n#ifdef BUMP\n    #ifdef OBJECTSPACE_NORMALMAP\n        // normalW = normalize(texture2D(bumpSampler, vBumpUV).xyz  * 2.0 - 1.0);\n        normalW = normalize(texture2D(bumpSampler, mainUv).xyz  * 2.0 - 1.0);\n        normalW = normalize(mat3(normalMatrix) * normalW);\n    #elif !defined(DETAIL)\n        // normalW = perturbNormal(TBN, texture2D(bumpSampler, vBumpUV + uvOffset).xyz, vBumpInfos.y);\n        normalW = perturbNormal(TBN, texture2D(bumpSampler, mainUv + uvOffset).xyz, vBumpInfos.y);\n    #else\n        // vec3 bumpNormal = texture2D(bumpSampler, vBumpUV + uvOffset).xyz * 2.0 - 1.0;\n        vec3 bumpNormal = texture2D(bumpSampler, mainUv + uvOffset).xyz * 2.0 - 1.0;\n        // Reference for normal blending: https://blog.selfshadow.com/publications/blending-in-detail/\n        #if DETAIL_NORMALBLENDMETHOD == 0 // whiteout\n            detailNormal.xy *= vDetailInfos.z;\n            vec3 blendedNormal = normalize(vec3(bumpNormal.xy + detailNormal.xy, bumpNormal.z * detailNormal.z));\n        #elif DETAIL_NORMALBLENDMETHOD == 1 // RNM\n            detailNormal.xy *= vDetailInfos.z;\n            bumpNormal += vec3(0.0, 0.0, 1.0);\n            detailNormal *= vec3(-1.0, -1.0, 1.0);\n            vec3 blendedNormal = bumpNormal * dot(bumpNormal, detailNormal) / bumpNormal.z - detailNormal;\n        #endif\n        normalW = perturbNormalBase(TBN, blendedNormal, vBumpInfos.y);\n    #endif\n#elif defined(DETAIL)\n        detailNormal.xy *= vDetailInfos.z;\n        normalW = perturbNormalBase(TBN, detailNormal, vDetailInfos.z);\n#endif\n",c.Effect.ShadersStore.mtoonVertexShader="// it is based on default.vertex.fx\n// This include is special, it will be replaced to UboDeclaration(WebGL2) or VertexDeclaration(WebGL1).\n// @see effect.ts\n#include<__decl__mtoonVertex>\n\n// Attributes\n\n#define CUSTOM_VERTEX_BEGIN\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n\n#include<helperFunctions>\n\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n\n// Uniforms\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n\n#include<mainUVVaryingDeclaration>[1..7]\n\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n// # if defined(SPECULARTERM)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n// # endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth)\n#include<samplerVertexDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask)\n\n// Additional Uniforms\n#ifdef OUTLINE_WIDTH\n    uniform sampler2D outlineWidthSampler;\n#endif\n\n// Output\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n\n#include<bumpVertexDeclaration>\n\n#include<clipPlaneVertexDeclaration>\n\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n// # ifdef REFLECTIONMAP_SKYBOX\n// varying vec3 vPositionUVW;\n// # endif\n\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n// varying vec3 vDirectionW;\n// # endif\n\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n\nvoid main(void) {\n\n    #define CUSTOM_VERTEX_MAIN_BEGIN\n\n    vec3 positionUpdated = position;\n#ifdef NORMAL\n    vec3 normalUpdated = normal;\n#endif\n#ifdef TANGENT\n    vec4 tangentUpdated = tangent;\n#endif\n#ifdef UV1\n    vec2 uvUpdated = uv;\n#endif\n\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n\n// # ifdef REFLECTIONMAP_SKYBOX\n//     vPositionUVW = positionUpdated;\n// # endif\n\n#define CUSTOM_VERTEX_UPDATE_POSITION\n\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n\n#include<instancesVertex>\n\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n    // Compute velocity before bones computation\n    vCurrentPosition = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\n    vPreviousPosition = previousViewProjection * finalPreviousWorld * vec4(positionUpdated, 1.0);\n#endif\n\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n\n    // Texture coordinates\n#ifndef UV1\n    vec2 uvUpdated = vec2(0., 0.);\n#endif\n#ifdef MAINUV1\n    vMainUV1 = uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n\n    float outlineTex = 1.0;\n    if (isOutline == 1.0) {\n#ifdef OUTLINE_WIDTH\n    #if OUTLINE_WIDTHDIRECTUV == 0\n        if (vOutlineWidthInfos.x == 0.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uvUpdated, 1.0, 0.0));\n        }\n        #ifdef UV2\n        else if (vOutlineWidthInfos.x == 1.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv2, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV3\n        else if (vOutlineWidthInfos.x == 2.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv3, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV4\n        else if (vOutlineWidthInfos.x == 3.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv4, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV5\n        else if (vOutlineWidthInfos.x == 4.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv5, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV6\n        else if (vOutlineWidthInfos.x == 5.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv6, 1.0, 0.0));\n        }\n        #endif\n    #elif defined(MAINUV1)\n        vec2 vOutlineWidthUV = vMainUV1;\n    #elif defined(MAINUV2)\n        vec2 vOutlineWidthUV = vMainUV2;\n    #else\n        vec2 vOutlineWidthUV = vec2(0., 0.);\n    #endif\n        outlineTex = texture2D(outlineWidthSampler, vOutlineWidthUV).r * vOutlineWidthInfos.y;\n#endif\n\n#if defined(MTOON_OUTLINE_WIDTH_WORLD) && defined(NORMAL)\n        // move slightly world normal\n        vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * length(transposeMat3(inverseMat3(mat3(finalWorld))) * normalUpdated) * normalUpdated;\n        positionUpdated += outlineOffset;\n#endif\n    } // End isOutline == 1.0\n\n    vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n#ifdef NORMAL\n    mat3 normalWorld = mat3(finalWorld);\n\n    #if defined(INSTANCES) && defined(THIN_INSTANCES)\n        vNormalW = normalUpdated / vec3(dot(normalWorld[0], normalWorld[0]), dot(normalWorld[1], normalWorld[1]), dot(normalWorld[2], normalWorld[2]));\n        vNormalW = normalize(normalWorld * vNormalW);\n    #else\n        #ifdef NONUNIFORMSCALING\n            normalWorld = transposeMat3(inverseMat3(normalWorld));\n        #endif\n\n        vNormalW = normalize(normalWorld * normalUpdated);\n    #endif\n#endif\n\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n\n#ifdef MULTIVIEW\n    if (gl_ViewID_OVR == 0u) {\n        gl_Position = viewProjection * worldPos;\n    } else {\n        gl_Position = viewProjectionR * worldPos;\n    }\n#else\n    gl_Position = viewProjection * worldPos;\n#endif\n\n    if (isOutline == 1.0) {\n#if defined(MTOON_OUTLINE_WIDTH_SCREEN) && defined(NORMAL)\n        vec3 viewNormal = transposeMat3(inverseMat3(mat3(view) * mat3(finalWorld))) * normalUpdated;\n        vec3 clipNormal = mat3(projection) * viewNormal;\n        vec2 projectedNormal = normalize(clipNormal.xy);\n        projectedNormal *= min(gl_Position.w, outlineScaledMaxDistance);\n        projectedNormal.x /= aspect; // aspect in original mtoon is y/x. aspect in babylon is x/y.\n        gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(normalize(viewNormal).z), 0.0, 1.0); // ignore offset when normal toward camera\n#endif\n\n        gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic from three-vrm\n    }\n\n    worldPos = finalWorld * vec4(positionUpdated, 1.0);\n    vPositionW = vec3(worldPos);\n\n#include<prePassVertex>\n\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n//     vDirectionW = normalize(vec3(finalWorld * vec4(positionUpdated, 0.0)));\n// # endif\n\n    #include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n    // # if defined(SPECULARTERM)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n    // # endif\n    #include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_MATRIXNAME_,shade,_INFONAME_,ShadeInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_MATRIXNAME_,receiveShadow,_INFONAME_,ReceiveShadowInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_MATRIXNAME_,shadingGrade,_INFONAME_,ShadingGradeInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_MATRIXNAME_,rim,_INFONAME_,RimInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_MATRIXNAME_,matCap,_INFONAME_,MatCapInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_MATRIXNAME_,uvAnimationMask,_INFONAME_,uvAnimationMaskInfos.x)\n\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\n    vColor = color;\n#elif defined(INSTANCESCOLOR) && INSTANCESCOLOR\n    vColor = instanceColor;\n#endif\n\n#include<pointCloudVertex>\n#include<logDepthVertex>\n\n#define CUSTOM_VERTEX_MAIN_END\n\n}\n",c.Effect.ShadersStore.mtoonFragmentShader="#include<__decl__mtoonFragment>\n\n#extension GL_OES_standard_derivatives : enable\n\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n\n#define CUSTOM_FRAGMENT_BEGIN\n\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n// Constants\n#define RECIPROCAL_PI2 0.15915494\n#define PI_2 6.28318530718\n#define EPS_COL 0.00001\n\n// Input\nvarying vec3 vPositionW;\n\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n\n#include<mainUVVaryingDeclaration>[1..7]\n\n// Helper functions\n#include<helperFunctions>\n\n// Lights\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n// Samplers\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_SAMPLERNAME_,shade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_SAMPLERNAME_,receiveShadow)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_SAMPLERNAME_,shadingGrade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_SAMPLERNAME_,rim)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_SAMPLERNAME_,matCap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth,_SAMPLERNAME_,outlineWidth)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_SAMPLERNAME_,uvAnimationMask)\n\n#include<mtoonFragmentFunctions>\n\n// # ifdef REFRACTION\n\n// # ifdef REFRACTIONMAP_3D\n// uniform samplerCube refractionCubeSampler;\n// # else\n// uniform sampler2D refraction2DSampler;\n// # endif\n\n// # endif\n\n// # if defined(SPECULARTERM)\n//     # include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n// # endif\n\n// // Fresnel\n// # include<fresnelFunction>\n\n// // Reflection\n// # ifdef REFLECTION\n// # ifdef REFLECTIONMAP_3D\n// uniform samplerCube reflectionCubeSampler;\n// # else\n// uniform sampler2D reflection2DSampler;\n// # endif\n\n// # ifdef REFLECTIONMAP_SKYBOX\n// varying vec3 vPositionUVW;\n// # else\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n// varying vec3 vDirectionW;\n// # endif\n\n// # endif\n\n// # include<reflectionFunction>\n\n// # endif\n\n#include<imageProcessingDeclaration>\n\n#include<imageProcessingFunctions>\n\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n\n#define CUSTOM_FRAGMENT_DEFINITIONS\n\nvoid main(void) {\n#ifdef MTOON_CLIP_IF_OUTLINE_IS_NONE\n    #ifdef MTOON_OUTLINE_WIDTH_WORLD\n    #elif defined(MTOON_OUTLINE_WIDTH_SCREEN)\n    #else\n        discard;\n    #endif\n#endif\n\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n\n#include<oitFragment>\n\n#include<clipPlaneFragment>\n\n    vec3 viewDirectionW = normalize(vEyePosition.xyz - vPositionW);\n\n    // Base color\n    vec4 baseColor = vec4(1., 1., 1., 1.);\n    vec3 diffuseColor = vec3(1., 1., 1.);\n\n    // Alpha\n    float alpha = 1.0;\n\n    // Bump\n#ifdef NORMAL\n    vec3 normalW = normalize(vNormalW);\n#else\n    vec3 normalW = normalize(-cross(dFdx(vPositionW), dFdy(vPositionW)));\n#endif\n\n#include<depthPrePass>\n\n    // Ambient color\n    vec3 baseAmbientColor = vec3(1., 1., 1.);\n    float glossiness = 0.;\n\n    // Lighting\n    vec3 diffuseBase = vec3(0., 0., 0.);\n    lightingInfo info;\n    float shadow = 1.;\n    vec3 lightDirection = vec3(0.0, 1.0, 0.0);\n    vec4 mtoonDiffuse = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // MToon UV\n    // All textures will use diffuse(_MainTex) UV\n    vec2 mainUv = vec2(0.0);\n#ifdef DIFFUSE\n    mainUv += vDiffuseUV;\n#elif defined(MAINUV1)\n    mainUv += vMainUV1;\n#elif defined(MAINUV2)\n    mainUv += vMainUV2;\n#endif\n\n    // uv anim\n    float uvAnim = time.y;\n#ifdef UV_ANIMATION_MASK\n    uvAnim *= texture2D(uvAnimationMaskSampler, mainUv).r;\n#endif\n    // translate uv in bottom-left origin coordinates.\n    // uv is reversed\n    mainUv += vec2(-uvAnimationScrollX, -uvAnimationScrollY) * uvAnim;\n    // rotate uv counter-clockwise around (0.5, 0.5) in bottom-left origin coordinates.\n    float rotateRad = uvAnimationRotation * PI_2 * uvAnim;\n    vec2 rotatePivot = vec2(0.5, 0.5);\n    mainUv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (mainUv - rotatePivot) + rotatePivot;\n\n#ifdef FLIP_U\n    mainUv.x = 1.0 - mainUv.x;\n#endif\n#ifdef FLIP_V\n    mainUv.y = 1.0 - mainUv.y;\n#endif\n\n#include<mtoonBumpFragment>\n\n#ifdef TWOSIDEDLIGHTING\n    normalW = gl_FrontFacing ? normalW : -normalW;\n#endif\n\n// include customized lightFragment\n#include<mtoonLightFragment>[0..maxSimultaneousLights]\n\n    vec3 finalDiffuse = clamp(diffuseBase, 0.0, 1.0) * baseColor.rgb;\n\n    // Composition\n    vec4 color = vec4(finalDiffuse, clamp(alpha, 0.0, 1.0));\n\n    color.rgb = max(color.rgb, 0.);\n#include<logDepthFragment>\n#include<fogFragment>\n\n// Apply image processing if relevant. As this applies in linear space,\n// We first move from gamma to linear.\n#ifdef IMAGEPROCESSINGPOSTPROCESS\n    color.rgb = toLinearSpace(color.rgb);\n#else\n    #ifdef IMAGEPROCESSING\n        // FIXME: support image processing\n        // color.rgb = toLinearSpace(color.rgb);\n        // color = applyImageProcessing(color);\n    #endif\n#endif\n\n    color.a *= visibility;\n\n#ifdef PREMULTIPLYALPHA\n    // Convert to associative (premultiplied) format if needed.\n    color.rgb *= color.a;\n#endif\n\n#ifdef PREPASS\n    float writeGeometryInfo = color.a > 0.4 ? 1.0 : 0.0;\n\n    gl_FragData[0] = color; // We can't split irradiance on std material\n\n    #ifdef PREPASS_POSITION\n    gl_FragData[PREPASS_POSITION_INDEX] = vec4(vPositionW, writeGeometryInfo);\n    #endif\n\n    #ifdef PREPASS_VELOCITY\n    vec2 a = (vCurrentPosition.xy / vCurrentPosition.w) * 0.5 + 0.5;\n    vec2 b = (vPreviousPosition.xy / vPreviousPosition.w) * 0.5 + 0.5;\n\n    vec2 velocity = abs(a - b);\n    velocity = vec2(pow(velocity.x, 1.0 / 3.0), pow(velocity.y, 1.0 / 3.0)) * sign(a - b) * 0.5 + 0.5;\n\n    gl_FragData[PREPASS_VELOCITY_INDEX] = vec4(velocity, 0.0, writeGeometryInfo);\n    #endif\n\n    #ifdef PREPASS_IRRADIANCE\n        gl_FragData[PREPASS_IRRADIANCE_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo); //  We can't split irradiance on std material\n    #endif\n\n    #ifdef PREPASS_DEPTH\n        gl_FragData[PREPASS_DEPTH_INDEX] = vec4(vViewPos.z, 0.0, 0.0, writeGeometryInfo); // Linear depth\n    #endif\n\n    #ifdef PREPASS_NORMAL\n        gl_FragData[PREPASS_NORMAL_INDEX] = vec4((view * vec4(normalW, 0.0)).rgb, writeGeometryInfo); // Normal\n    #endif\n\n    #ifdef PREPASS_ALBEDO_SQRT\n        gl_FragData[PREPASS_ALBEDO_SQRT_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo); // We can't split albedo on std material\n    #endif\n    #ifdef PREPASS_REFLECTIVITY\n        #if defined(SPECULAR)\n            gl_FragData[PREPASS_REFLECTIVITY_INDEX] = vec4(specularMapColor.rgb, specularMapColor.a * writeGeometryInfo);\n        #else\n            gl_FragData[PREPASS_REFLECTIVITY_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo);\n        #endif\n    #endif\n#endif\n\n#if !defined(PREPASS) || defined(WEBGL2)\n    gl_FragColor = color;\n#endif\n\n#if ORDER_INDEPENDENT_TRANSPARENCY\n    if (fragDepth == nearestDepth) {\n        frontColor.rgb += color.rgb * color.a * alphaMultiplier;\n        frontColor.a = 1.0 - alphaMultiplier * (1.0 - color.a);\n    } else {\n        backColor += color;\n    }\n#endif\n\n#define CUSTOM_FRAGMENT_MAIN_END\n\n}\n"),this.inspectableCustomProperties=this.inspectableCustomProperties||[],this.inspectableCustomProperties.push({label:"DiffuseColor",propertyName:"diffuseColor",type:g.InspectableType.Color3},{label:"AmbientColor",propertyName:"ambientColor",type:g.InspectableType.Color3},{label:"EmissiveColor",propertyName:"emissiveColor",type:g.InspectableType.Color3},{label:"ShadeColor",propertyName:"shadeColor",type:g.InspectableType.Color3},{label:"RimColor",propertyName:"rimColor",type:g.InspectableType.Color3},{label:"OutlineColor",propertyName:"outlineColor",type:g.InspectableType.Color3},{label:"ReceiveShadowRate",propertyName:"receiveShadowRate",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadingGradeRate",propertyName:"shadingGradeRate",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadeShift",propertyName:"shadeShift",type:g.InspectableType.Slider,min:-1,max:1,step:.01},{label:"ShadeToony",propertyName:"shadeToony",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"LightColorAttenuation",propertyName:"lightColorAttenuation",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"IndirectLightIntensity",propertyName:"indirectLightIntensity",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimLightingMix",propertyName:"rimLightingMix",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimFresnelPower",propertyName:"rimFresnelPower",type:g.InspectableType.Slider,min:.01,max:100,step:4},{label:"RimLift",propertyName:"rimLift",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"OutlineWidth",propertyName:"outlineWidth",type:g.InspectableType.Slider,min:.01,max:1,step:.01},{label:"OutlineScaledMaxDistance",propertyName:"outlineScaledMaxDistance",type:g.InspectableType.Slider,min:1,max:10,step:.01},{label:"OutlineLightingMix",propertyName:"outlineLightingMix",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"DebugMode",propertyName:"debugMode",type:g.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineWidthMode",propertyName:"outlineWidthMode",type:g.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineColorMode",propertyName:"outlineColorMode",type:g.InspectableType.Slider,min:0,max:1,step:1},{label:"CullMode",propertyName:"cullMode",type:g.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineCullMode",propertyName:"outlineCullMode",type:g.InspectableType.Slider,min:0,max:2,step:1},{label:"AlphaCutOff",propertyName:"alphaCutOff",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"UV Animation Scroll X",propertyName:"uvAnimationScrollX",type:g.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Scroll Y",propertyName:"uvAnimationScrollY",type:g.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Rotation",propertyName:"uvAnimationRotation",type:g.InspectableType.Slider,min:-.5,max:.5,step:.01})}get appendedTextures(){return[this._diffuseTexture,this._emissiveTexture,this._bumpTexture,this._shadeTexture,this._receiveShadowTexture,this._shadingGradeTexture,this._rimTexture,this._matCapTexture,this._outlineWidthTexture,this._uvAnimationMaskTexture]}get appendedActiveTextures(){return this.appendedTextures.filter((e=>null!==e))}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(e){this._attachImageProcessingConfiguration(e),this._markAllSubMeshesAsTexturesDirty()}_attachImageProcessingConfiguration(e){e!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),this._imageProcessingConfiguration=e||this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add((()=>{this._markAllSubMeshesAsImageProcessingDirty()}))))}get isPrePassCapable(){return!1}get cameraColorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set cameraColorCurvesEnabled(e){this.imageProcessingConfiguration.colorCurvesEnabled=e}get cameraColorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set cameraColorGradingEnabled(e){this.imageProcessingConfiguration.colorGradingEnabled=e}get cameraToneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set cameraToneMappingEnabled(e){this._imageProcessingConfiguration.toneMappingEnabled=e}get cameraExposure(){return this._imageProcessingConfiguration.exposure}set cameraExposure(e){this._imageProcessingConfiguration.exposure=e}get cameraContrast(){return this._imageProcessingConfiguration.contrast}set cameraContrast(e){this._imageProcessingConfiguration.contrast=e}get cameraColorGradingTexture(){return this._imageProcessingConfiguration.colorGradingTexture}set cameraColorGradingTexture(e){this._imageProcessingConfiguration.colorGradingTexture=e}get cameraColorCurves(){return this._imageProcessingConfiguration.colorCurves}set cameraColorCurves(e){this._imageProcessingConfiguration.colorCurves=e}get canRenderToMRT(){return!0}get bumpScale(){return this._bumpScale}set bumpScale(e){this._bumpScale=e}get receiveShadowRate(){return this._receiveShadowRate}set receiveShadowRate(e){this._receiveShadowRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadingGradeRate(){return this._shadingGradeRate}set shadingGradeRate(e){this._shadingGradeRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadeShift(){return this._shadeShift}set shadeShift(e){this._shadeShift=Math.max(-1,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadeToony(){return this._shadeToony}set shadeToony(e){this._shadeToony=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get lightColorAttenuation(){return this._lightColorAttenuation}set lightColorAttenuation(e){this._lightColorAttenuation=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get indirectLightIntensity(){return this._indirectLightIntensity}set indirectLightIntensity(e){this._indirectLightIntensity=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get rimLightingMix(){return this._rimLightingMix}set rimLightingMix(e){this._rimLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get rimFresnelPower(){return this._rimFresnelPower}set rimFresnelPower(e){this._rimFresnelPower=Math.max(0,Math.min(100,e)),this._markAllSubMeshesAsLightsDirty()}get rimLift(){return this._rimLift}set rimLift(e){this._rimLift=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get outlineWidth(){return this._outlineWidth}set outlineWidth(e){this._outlineWidth=Math.max(.01,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()}get outlineScaledMaxDistance(){return this._outlineScaledMaxDistance}set outlineScaledMaxDistance(e){this._outlineScaledMaxDistance=Math.max(1,Math.min(10,e)),this._markAllSubMeshesAsAttributesDirty()}get outlineLightingMix(){return this._outlineLightingMix}set outlineLightingMix(e){this._outlineLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()}get uvAnimationScrollX(){return this._uvAnimationScrollX}set uvAnimationScrollX(e){this._uvAnimationScrollX=e,this._markAllSubMeshesAsMiscDirty()}get uvAnimationScrollY(){return this._uvAnimationScrollY}set uvAnimationScrollY(e){this._uvAnimationScrollY=e,this._markAllSubMeshesAsMiscDirty()}get uvAnimationRotation(){return this._uvAnimationRotation}set uvAnimationRotation(e){this._uvAnimationRotation=e,this._markAllSubMeshesAsMiscDirty()}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest=e,e?this.alphaBlend?this._transparencyMode=l.Material.MATERIAL_ALPHATESTANDBLEND:this._transparencyMode=l.Material.MATERIAL_ALPHATEST:this.alphaBlend?this._transparencyMode=l.Material.MATERIAL_ALPHABLEND:this._transparencyMode=l.Material.MATERIAL_OPAQUE,this._markAllSubMeshesAsMiscDirty()}get alphaBlend(){return this._alphaBlend}set alphaBlend(e){this._alphaBlend=e,e?(this.backFaceCulling=!0,this.alphaTest?this._transparencyMode=l.Material.MATERIAL_ALPHATESTANDBLEND:this._transparencyMode=l.Material.MATERIAL_ALPHABLEND):this.alphaTest?this._transparencyMode=l.Material.MATERIAL_ALPHATEST:this._transparencyMode=l.Material.MATERIAL_OPAQUE,this._markAllSubMeshesAsMiscDirty()}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(e){this._outlineWidthMode=e,e===N.None||this.outlineRenderer||(this.outlineRenderer=new M(this.getScene(),this)),this._markAllSubMeshesAsMiscDirty()}enableOutlineRender(){this.isOutline=1}disaableOutlineRender(){this.isOutline=0}get cullMode(){return this._cullMode}set cullMode(e){switch(this._cullMode=e,this._cullMode){case b.Off:this.backFaceCulling=!1,this.sideOrientation=l.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1;break;case b.Front:this.backFaceCulling=!0,this.sideOrientation=l.Material.CounterClockWiseSideOrientation,this.twoSidedLighting=!0;break;case b.Back:this.backFaceCulling=!0,this.sideOrientation=l.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1}this._markAllSubMeshesAsMiscDirty()}applyOutlineCullMode(){this.storedCullMode=this.cullMode,this.cullMode=this._outlineCullMode}restoreOutlineCullMode(){this.cullMode=this.storedCullMode}getOutlineRendererName(){return this.outlineRenderer?this.outlineRenderer.name:""}get hasRenderTargetTextures(){return!1}getClassName(){return"MToonMaterial"}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(e){const t=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported;this._useLogarithmicDepth!==t&&(this._useLogarithmicDepth=t,this._markAllSubMeshesAsMiscDirty())}needAlphaBlending(){return!this._disableAlphaBlending&&(this.alpha<1||this._shouldUseAlphaFromDiffuseTexture())}needAlphaTesting(){return!!this._forceAlphaTest||!!this._alphaTest||this._hasAlphaChannel()&&(null==this._transparencyMode||this._transparencyMode===l.Material.MATERIAL_ALPHATEST)}_shouldUseAlphaFromDiffuseTexture(){return null!=this._diffuseTexture&&this._diffuseTexture.hasAlpha&&this._useAlphaFromDiffuseTexture&&this._transparencyMode!==l.Material.MATERIAL_OPAQUE}_hasAlphaChannel(){return null!==this._diffuseTexture&&this._diffuseTexture.hasAlpha}getAlphaTestTexture(){return this._diffuseTexture}isReadyForSubMesh(e,t,i=!1){if(this._uniformBufferLayoutBuilt||this.buildUniformLayout(),t.effect&&this.isFrozen&&t.effect._wasPreviouslyReady&&t.effect._wasPreviouslyUsingInstances===i)return!0;t.materialDefines||(this._callbackPluginEventGeneric(p.MaterialPluginEvent.GetDefineNames,this._eventInfo),t.materialDefines=new I);const n=this.getScene(),r=t.materialDefines;if(this._isReadyForSubMesh(t))return!0;const a=n.getEngine();r._needNormals=d.MaterialHelper.PrepareDefinesForLights(n,e,r,this.specularSupported,this._maxSimultaneousLights,this._disableLighting),this.outlineWidthMode!==N.None&&(r._needNormals=!0),this.applyDefines(r),d.MaterialHelper.PrepareDefinesForMultiview(n,r);const l=this.needAlphaBlendingForMesh(e)&&n.useOrderIndependentTransparency;if(d.MaterialHelper.PrepareDefinesForOIT(n,r,l),r._areTexturesDirty){this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._cacheHasRenderTargetTextures=this._eventInfo.hasRenderTargetTextures,r._needUVs=!1;for(let e=1;e<=u.Constants.MAX_SUPPORTED_UV_SETS;++e)r["MAINUV"+e]=!1;if(n.texturesEnabled){if(!(this.isReadyForTexture(this._diffuseTexture,r,"DIFFUSE")&&this.isReadyForTexture(this._emissiveTexture,r,"EMISSIVE")&&this.isReadyForTexture(this._shadeTexture,r,"SHADE")&&this.isReadyForTexture(this._receiveShadowTexture,r,"RECEIVE_SHADOW")&&this.isReadyForTexture(this._shadingGradeTexture,r,"SHADING_GRADE")&&this.isReadyForTexture(this._rimTexture,r,"RIM")&&this.isReadyForTexture(this._matCapTexture,r,"MATCAP")&&this.isReadyForTexture(this._outlineWidthTexture,r,"OUTLINE_WIDTH")&&this.isReadyForTexture(this._uvAnimationMaskTexture,r,"UV_ANIMATION_MASK")))return!1;if(n.getEngine().getCaps().standardDerivatives&&this._bumpTexture){if(!this._bumpTexture.isReady())return!1;d.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture,r,"BUMP"),r.PARALLAX=this.useParallax,r.PARALLAXOCCLUSION=this.useParallaxOcclusion,r.OBJECTSPACE_NORMALMAP=this.useObjectSpaceNormalMap}else r.BUMP=!1,r.PARALLAX=!1,r.PARALLAXOCCLUSION=!1;r.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else r.DIFFUSE=!1,r.EMISSIVE=!1,r.SHADE=!1,r.RECEIVE_SHADOW=!1,r.SHADING_GRADE=!1,r.RIM=!1,r.MATCAP=!1,r.OUTLINE_WIDTH=!1,r.BUMP=!1,r.UV_ANIMATION_MASK=!1;r.ALPHAFROMDIFFUSE=this._shouldUseAlphaFromDiffuseTexture(),r.PREMULTIPLYALPHA=this.alphaMode===u.Constants.ALPHA_PREMULTIPLIED||this.alphaMode===u.Constants.ALPHA_PREMULTIPLIED_PORTERDUFF,r.ALPHATEST_AFTERALLALPHACOMPUTATIONS=null!==this.transparencyMode,r.ALPHABLEND=null===this.transparencyMode||this.needAlphaBlendingForMesh(e)}if(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=r,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),!this._eventInfo.isReadyForSubMesh)return!1;if(r._areImageProcessingDirty&&this._imageProcessingConfiguration){if(!this._imageProcessingConfiguration.isReady())return!1;this._imageProcessingConfiguration.prepareDefines(r)}if(this.flipU!==r.FLIP_U&&(r.FLIP_U=this.flipU,r.markAsUnprocessed()),this.flipV!==r.FLIP_V&&(r.FLIP_V=this.flipV,r.markAsUnprocessed()),d.MaterialHelper.PrepareDefinesForMisc(e,n,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(e)||this._forceAlphaTest,r),d.MaterialHelper.PrepareDefinesForFrameBoundValues(n,a,r,i,null,t.getRenderingMesh().hasThinInstances),this._eventInfo.defines=r,this._eventInfo.mesh=e,this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo),d.MaterialHelper.PrepareDefinesForAttributes(e,r,this.useVertexColor,this.useBones,this.useMorphTargets,this.useVertexAlpha,this.useBakedVertexAnimation),this._callbackPluginEventPrepareDefines(this._eventInfo),r.isDirty){const i=r._areLightsDisposed;r.markAsProcessed();const l=new f.EffectFallbacks;r.BUMP&&l.addFallback(0,"BUMP"),r.PARALLAX&&l.addFallback(1,"PARALLAX"),r.PARALLAXOCCLUSION&&l.addFallback(0,"PARALLAXOCCLUSION"),r.FOG&&l.addFallback(1,"FOG"),r.POINTSIZE&&l.addFallback(0,"POINTSIZE"),r.LOGARITHMICDEPTH&&l.addFallback(0,"LOGARITHMICDEPTH"),d.MaterialHelper.HandleFallbacksForShadows(r,l,this._maxSimultaneousLights),r.MULTIVIEW&&l.addFallback(0,"MULTIVIEW");const h=[o.VertexBuffer.PositionKind];r.NORMAL&&h.push(o.VertexBuffer.NormalKind),r.TANGENT&&h.push(o.VertexBuffer.TangentKind);for(let e=1;e<=u.Constants.MAX_SUPPORTED_UV_SETS;++e)r["UV"+e]&&h.push(`uv${1===e?"":e}`);r.INSTANCESCOLOR&&h.push(o.VertexBuffer.ColorInstanceKind),d.MaterialHelper.PrepareAttributesForBones(h,e,r,l),d.MaterialHelper.PrepareAttributesForInstances(h,r),d.MaterialHelper.PrepareAttributesForMorphTargets(h,e,r),d.MaterialHelper.PrepareAttributesForBakedVertexAnimation(h,e,r);const c="mtoon",m=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","visibility","vFogInfos","vFogColor","pointSize","mBones","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vClipPlane5","vClipPlane6","logarithmicDepthConstant","vTangentSpaceParams","alphaCutOff","boneTextureWidth","morphTargetTextureInfo","morphTargetTextureIndices","vDiffuseColor","vDiffuseInfos","diffuseMatrix","vEmissiveColor","vEmissiveInfos","emissiveMatrix","vBumpInfos","bumpMatrix","vShadeColor","vShadeInfos","shadeMatrix","vReceiveShadowInfos","receiveShadowMatrix","vShadingGradeInfos","shadingGradeMatrix","vRimColor","vRimInfos","RimMatrix","vMatCapInfos","MatCapMatrix","vOutlineColor","vOutlineWidthInfos","outlineWidthMatrix","aspect","isOutline","shadingGradeRate","receiveShadowRate","shadeShift","shadeToony","rimLightingMix","rimFresnelPower","rimLift","lightColorAttenuation","indirectLightIntensity","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","uvAnimationScrollX","uvAnimationScrollY","uvAnimationRotation","vEyeUp","time","projection"],g=["diffuseSampler","ambientSampler","emissiveSampler","bumpSampler","boneSampler","morphTargets","oitDepthSampler","oitFrontColorSampler","shadeSampler","receiveShadowSampler","shadingGradeSampler","rimSampler","matCapSampler","outlineWidthSampler","uvAnimationMaskSampler"],_=["Material","Scene","Mesh"];this._eventInfo.fallbacks=l,this._eventInfo.fallbackRank=0,this._eventInfo.defines=r,this._eventInfo.uniforms=m,this._eventInfo.attributes=h,this._eventInfo.samplers=g,this._eventInfo.uniformBuffersNames=_,this._eventInfo.customCode=void 0,this._eventInfo.mesh=e,this._callbackPluginEventGeneric(p.MaterialPluginEvent.PrepareEffect,this._eventInfo),s.ImageProcessingConfiguration&&(s.ImageProcessingConfiguration.PrepareUniforms(m,r),s.ImageProcessingConfiguration.PrepareSamplers(g,r)),d.MaterialHelper.PrepareUniformsAndSamplersList({uniformsNames:m,uniformBuffersNames:_,samplers:g,defines:r,maxSimultaneousLights:this._maxSimultaneousLights});const M={},A=r.toString(),v=t.effect;let T=n.getEngine().createEffect(c,{attributes:h,uniformsNames:m,uniformBuffersNames:_,samplers:g,defines:A,fallbacks:l,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:r.NUM_MORPH_INFLUENCERS},processFinalCode:M.processFinalCode,processCodeAfterIncludes:this._eventInfo.customCode,multiTarget:r.PREPASS},a);if(T)if(this._onEffectCreatedObservable&&(S.effect=T,S.subMesh=t,this._onEffectCreatedObservable.notifyObservers(S)),this.allowShaderHotSwapping&&v&&!T.isReady()){if(T=v,r.markAsUnprocessed(),i)return r._areLightsDisposed=!0,!1}else n.resetCachedMaterial(),t.setEffect(T,r,this._materialContext)}return!(!t.effect||!t.effect.isReady()||(r._renderId=n.getRenderId(),t.effect._wasPreviouslyReady=!0,t.effect._wasPreviouslyUsingInstances=i,0))}buildUniformLayout(){const e=this._uniformBuffer;e.addUniform("vDiffuseColor",4),e.addUniform("vDiffuseInfos",2),e.addUniform("diffuseMatrix",16),e.addUniform("vEmissiveColor",3),e.addUniform("vEmissiveInfos",2),e.addUniform("emissiveMatrix",16),e.addUniform("vBumpInfos",3),e.addUniform("bumpMatrix",16),e.addUniform("vShadeColor",3),e.addUniform("vShadeInfos",2),e.addUniform("shadeMatrix",16),e.addUniform("vReceiveShadowInfos",2),e.addUniform("receiveShadowMatrix",16),e.addUniform("vShadingGradeInfos",2),e.addUniform("shadingGradeMatrix",16),e.addUniform("vRimColor",3),e.addUniform("vRimInfos",2),e.addUniform("rimMatrix",16),e.addUniform("vMatCapInfos",2),e.addUniform("matCapMatrix",16),e.addUniform("vOutlineColor",3),e.addUniform("vOutlineWidthInfos",2),e.addUniform("outlineWidthMatrix",16),e.addUniform("vUvAnimationMaskInfos",2),e.addUniform("uvAnimationMaskMatrix",16),e.addUniform("vTangentSpaceParams",2),e.addUniform("pointSize",1),e.addUniform("shadingGradeRate",1),e.addUniform("receiveShadowRate",1),e.addUniform("shadeShift",1),e.addUniform("shadeToony",1),e.addUniform("lightColorAttenuation",1),e.addUniform("indirectLightIntensity",1),e.addUniform("rimLightingMix",1),e.addUniform("rimFresnelPower",1),e.addUniform("rimLift",1),e.addUniform("outlineWidth",1),e.addUniform("outlineScaledMaxDistance",1),e.addUniform("outlineLightingMix",1),e.addUniform("uvAnimationScrollX",1),e.addUniform("uvAnimationScrollY",1),e.addUniform("uvAnimationRotation",1),e.addUniform("vEyeUp",3),e.addUniform("alphaCutOff",1),e.addUniform("vAmbientColor",3),e.addUniform("aspect",1),e.addUniform("isOutline",1),e.addUniform("time",4),e.addUniform("visibility",1),super.buildUniformLayout()}bindForSubMesh(e,t,i){var a;const o=this.getScene(),s=i.materialDefines,l=i.effect;if(!s||!l)return;this._activeEffect=l,t.getMeshUniformBuffer().bindToEffect(l,"Mesh"),t.transferToEffect(e),this._uniformBuffer.bindToEffect(l,"Material"),this._eventInfo.subMesh=i,this._callbackPluginEventHardBindForSubMesh(this._eventInfo),s.OBJECTSPACE_NORMALMAP&&(e.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const h=this._mustRebind(o,l,t.visibility);d.MaterialHelper.BindBonesParameters(t,l);const u=this._uniformBuffer;if(h){this.bindViewProjection(l),u.useUbo&&this.isFrozen&&u.isSync||(o.texturesEnabled&&(this.bindTexture(this._diffuseTexture,u,l,"diffuse","vDiffuseInfos"),this.bindTexture(this._emissiveTexture,u,l,"emissive","vEmissiveInfos"),this._bumpTexture&&o.getEngine().getCaps().standardDerivatives&&(u.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this._bumpScale),d.MaterialHelper.BindTextureMatrix(this._bumpTexture,u,"bump"),l.setTexture("bumpSampler",this._bumpTexture),o._mirroredCameraPosition?u.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?1:-1,this._invertNormalMapY?1:-1):u.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?-1:1,this._invertNormalMapY?-1:1)),this.bindTexture(this._shadeTexture,u,l,"shade","vShadeInfos"),this.bindTexture(this._receiveShadowTexture,u,l,"receiveShadow","vReceiveShadowInfos"),this.bindTexture(this._shadingGradeTexture,u,l,"shadingGrade","vShadingGradeInfos"),this.bindTexture(this._rimTexture,u,l,"rim","vRimInfos"),this.bindTexture(this._matCapTexture,u,l,"matCap","vMatCapInfos"),this.bindTexture(this._outlineWidthTexture,u,l,"outlineWidth","vOutlineWidthInfos"),this.bindTexture(this._uvAnimationMaskTexture,u,l,"uvAnimationMask","vUvAnimationMaskInfos"),this._hasAlphaChannel()&&u.updateFloat("alphaCutOff",this.alphaCutOff)),this.pointsCloud&&u.updateFloat("pointSize",this.pointSize),u.updateFloat("receiveShadowRate",this._receiveShadowRate),u.updateFloat("shadingGradeRate",this._shadingGradeRate),u.updateFloat("shadeShift",this._shadeShift),u.updateFloat("shadeToony",this._shadeToony),u.updateFloat("lightColorAttenuation",this._lightColorAttenuation),u.updateFloat("indirectLightIntensity",this._indirectLightIntensity),u.updateFloat("rimLightingMix",this._rimLightingMix),u.updateFloat("rimFresnelPower",this._rimFresnelPower),u.updateFloat("rimLift",this._rimLift),u.updateFloat("outlineWidth",this._outlineWidth),u.updateFloat("outlineScaledMaxDistance",this._outlineScaledMaxDistance),u.updateFloat("outlineLightingMix",this._outlineLightingMix),u.updateFloat("uvAnimationScrollX",this._uvAnimationScrollX),u.updateFloat("uvAnimationScrollY",this._uvAnimationScrollY),u.updateFloat("uvAnimationRotation",this._uvAnimationRotation),o.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),u.updateColor3("vAmbientColor",this._globalAmbientColor),u.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),u.updateColor3("vEmissiveColor",this.emissiveColor),u.updateColor3("vShadeColor",this.shadeColor),u.updateColor3("vRimColor",this.rimColor),u.updateColor4("vOutlineColor",this.outlineColor,1),u.updateVector3("vEyeUp",o.activeCamera.upVector));const e=o;e.useOrderIndependentTransparency&&this.needAlphaBlendingForMesh(t)&&e.depthPeelingRenderer&&e.depthPeelingRenderer.bind(l),this._eventInfo.subMesh=i,this._callbackPluginEventBindForSubMesh(this._eventInfo),d.MaterialHelper.BindClipPlane(l,o),this.bindEyePosition(l)}else o.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0);if(h||!this.isFrozen){o.lightsEnabled&&!this._disableLighting&&d.MaterialHelper.BindLights(o,t,l,s,this._maxSimultaneousLights),(o.fogEnabled&&t.applyFog&&o.fogMode!==n.Scene.FOGMODE_NONE||t.receiveShadows)&&this.bindView(l),d.MaterialHelper.BindFogParameters(o,t,l),s.NUM_MORPH_INFLUENCERS&&d.MaterialHelper.BindMorphTargetParameters(t,l),s.BAKED_VERTEX_ANIMATION_TEXTURE&&(null===(a=t.bakedVertexAnimationManager)||void 0===a||a.bind(l,s.INSTANCES)),this.useLogarithmicDepth&&d.MaterialHelper.BindLogDepth(s,l,o),this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.applyByPostProcess&&this._imageProcessingConfiguration.bind(this._activeEffect),u.updateFloat("aspect",o.getEngine().getAspectRatio(o.activeCamera)),u.updateFloat("isOutline",this.isOutline);const e=window.performance.now()/1e3;u.updateVector4("time",new r.Vector4(e/20,e,2*e,3*e))}this._afterBind(t,this._activeEffect),u.update()}getAnimatables(){const e=super.getAnimatables();for(const t of this.appendedActiveTextures)t.animations&&t.animations.length>0&&e.push(t);return e}getActiveTextures(){return super.getActiveTextures().concat(this.appendedActiveTextures)}hasTexture(e){if(super.hasTexture(e))return!0;for(const t of this.appendedActiveTextures)if(t===e)return!0;return!1}dispose(e,t){if(delete this.outlineRenderer,t)for(const e of this.appendedActiveTextures)e.dispose();this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),super.dispose(e,t)}clone(e){const i=t.SerializationHelper.Clone((()=>new D(e,this.getScene())),this);return i.name=e,i.id=e,this.stencil.copyTo(i.stencil),i}static Parse(e,i,n){const r=t.SerializationHelper.Parse((()=>new D(e.name,i)),e,i,n);return e.stencil&&r.stencil.parse(e.stencil,i,n),r}bindTexture(e,t,i,n,r){e&&(this._uniformBuffer.updateFloat2(r,e.coordinatesIndex,e.level),d.MaterialHelper.BindTextureMatrix(e,t,n),i.setTexture(`${n}Sampler`,e))}isReadyForTexture(e,t,i){return e?!!e.isReadyOrNotBlocking()&&(d.MaterialHelper.PrepareDefinesForMergedUV(e,t,i),!0):(t[i]=!1,!0)}applyDefines(e){switch(this._debugMode){case E.Normal:!0!==e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!0,e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed());break;case E.LitShadeRate:!0!==e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_NORMAL=!1,e.MTOON_DEBUG_LITSHADERATE=!0,e.markAsUnprocessed());break;case E.None:!0===e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!1,e.markAsUnprocessed()),!0===e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed())}switch(this.outlineWidthMode){case N.WorldCorrdinates:!0!==e.MTOON_OUTLINE_WIDTH_WORLD&&(e.MTOON_OUTLINE_WIDTH_WORLD=!0,e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.markAsUnprocessed());break;case N.ScreenCoordinates:!0!==e.MTOON_OUTLINE_WIDTH_SCREEN&&(e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.MTOON_OUTLINE_WIDTH_SCREEN=!0,e.markAsUnprocessed());break;case N.None:!1===e.MTOON_OUTLINE_WIDTH_SCREEN&&!1===e.MTOON_OUTLINE_WIDTH_WORLD||(e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.markAsUnprocessed())}switch(this.outlineColorMode){case x.FixedColor:!0!==e.MTOON_OUTLINE_COLOR_FIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!0,e.MTOON_OUTLINE_COLOR_MIXED=!1,e.markAsUnprocessed());break;case x.MixedLighting:!0!==e.MTOON_OUTLINE_COLOR_MIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!1,e.MTOON_OUTLINE_COLOR_MIXED=!0,e.markAsUnprocessed())}}}e([(0,t.serializeAsTexture)("diffuseTexture")],D.prototype,"_diffuseTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],D.prototype,"diffuseTexture",void 0),e([(0,t.serializeAsTexture)("emissiveTexture")],D.prototype,"_emissiveTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"emissiveTexture",void 0),e([(0,t.serializeAsTexture)("bumpTexture")],D.prototype,"_bumpTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"bumpTexture",void 0),e([(0,t.serializeAsTexture)("shadeTexture")],D.prototype,"_shadeTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"shadeTexture",void 0),e([(0,t.serializeAsTexture)("receiveShadowTexture")],D.prototype,"_receiveShadowTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"receiveShadowTexture",void 0),e([(0,t.serializeAsTexture)("shadingGradeTexture")],D.prototype,"_shadingGradeTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"shadingGradeTexture",void 0),e([(0,t.serializeAsTexture)("rimTexture")],D.prototype,"_rimTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"rimTexture",void 0),e([(0,t.serializeAsTexture)("matCapTexture")],D.prototype,"_matCapTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"matCapTexture",void 0),e([(0,t.serializeAsTexture)("outlineWidthTexture")],D.prototype,"_outlineWidthTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"outlineWidthTexture",void 0),e([(0,t.serializeAsTexture)("outlineWidthTexture")],D.prototype,"_uvAnimationMaskTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"uvAnimationMaskTexture",void 0),e([(0,t.serializeAsColor3)("diffuse")],D.prototype,"diffuseColor",void 0),e([(0,t.serialize)("ambient")],D.prototype,"ambientColor",void 0),e([(0,t.serialize)("emissive")],D.prototype,"emissiveColor",void 0),e([(0,t.serialize)("shade")],D.prototype,"shadeColor",void 0),e([(0,t.serialize)("rim")],D.prototype,"rimColor",void 0),e([(0,t.serialize)("outline")],D.prototype,"outlineColor",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"useEmissiveAsIllumination",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"linkEmissiveWithDiffuse",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"useReflectionOverAlpha",void 0),e([(0,t.serialize)("disableLighting")],D.prototype,"_disableLighting",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsLightsDirty")],D.prototype,"disableLighting",void 0),e([(0,t.serialize)()],D.prototype,"alphaCutOff",void 0),e([(0,t.serialize)("useAlphaFromDiffuseTexture")],D.prototype,"_useAlphaFromDiffuseTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],D.prototype,"useAlphaFromDiffuseTexture",void 0),e([(0,t.serialize)("maxSimultaneousLights")],D.prototype,"_maxSimultaneousLights",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsLightsDirty")],D.prototype,"maxSimultaneousLights",void 0),e([(0,t.serialize)("invertNormalMapX")],D.prototype,"_invertNormalMapX",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"invertNormalMapX",void 0),e([(0,t.serialize)("invertNormalMapY")],D.prototype,"_invertNormalMapY",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"invertNormalMapY",void 0),e([(0,t.serialize)("twoSidedLighting")],D.prototype,"_twoSidedLighting",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"twoSidedLighting",void 0),e([(0,t.serialize)()],D.prototype,"bumpScale",null),e([(0,t.serialize)()],D.prototype,"receiveShadowRate",null),e([(0,t.serialize)()],D.prototype,"shadingGradeRate",null),e([(0,t.serialize)()],D.prototype,"shadeShift",null),e([(0,t.serialize)()],D.prototype,"shadeToony",null),e([(0,t.serialize)()],D.prototype,"lightColorAttenuation",null),e([(0,t.serialize)()],D.prototype,"indirectLightIntensity",null),e([(0,t.serialize)()],D.prototype,"rimLightingMix",null),e([(0,t.serialize)()],D.prototype,"rimFresnelPower",null),e([(0,t.serialize)()],D.prototype,"rimLift",null),e([(0,t.serialize)()],D.prototype,"outlineWidth",null),e([(0,t.serialize)()],D.prototype,"outlineScaledMaxDistance",null),e([(0,t.serialize)()],D.prototype,"outlineLightingMix",null),e([(0,t.serialize)()],D.prototype,"uvAnimationScrollX",null),e([(0,t.serialize)()],D.prototype,"uvAnimationScrollY",null),e([(0,t.serialize)()],D.prototype,"uvAnimationRotation",null),e([(0,t.serialize)("alphaTest")],D.prototype,"_alphaTest",void 0),e([(0,t.serialize)()],D.prototype,"alphaTest",null),e([(0,t.serialize)()],D.prototype,"alphaBlend",null),e([(0,t.serialize)("debugMode")],D.prototype,"_debugMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],D.prototype,"debugMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],D.prototype,"outlineColorMode",void 0),e([(0,t.serialize)()],D.prototype,"cullMode",null),e([(0,t.serialize)()],D.prototype,"_outlineCullMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],D.prototype,"outlineCullMode",void 0),e([(0,t.serialize)("flipU")],D.prototype,"flipU",void 0),e([(0,t.serialize)("flipV")],D.prototype,"flipV",void 0),e([(0,t.serialize)()],D.prototype,"useLogarithmicDepth",null)})(),T})(),e.exports=n(i(388),i(474),i(538),i(694),i(548),i(908),i(677),i(66),i(721),i(221),i(556),i(55),i(272),i(824),i(628),i(812),i(667),i(713))},235:e=>{"use strict";e.exports=t},908:e=>{"use strict";e.exports=s},556:e=>{"use strict";e.exports=f},4:e=>{"use strict";e.exports=T},6:e=>{"use strict";e.exports=x},272:e=>{"use strict";e.exports=m},55:e=>{"use strict";e.exports=c},677:e=>{"use strict";e.exports=l},66:e=>{"use strict";e.exports=h},824:e=>{"use strict";e.exports=p},713:e=>{"use strict";e.exports=A},221:e=>{"use strict";e.exports=u},628:e=>{"use strict";e.exports=g},721:e=>{"use strict";e.exports=d},53:e=>{"use strict";e.exports=S},197:t=>{"use strict";t.exports=e},548:e=>{"use strict";e.exports=o},694:e=>{"use strict";e.exports=a},705:e=>{"use strict";e.exports=I},564:e=>{"use strict";e.exports=E},388:e=>{"use strict";e.exports=i},812:e=>{"use strict";e.exports=_},474:e=>{"use strict";e.exports=n},538:e=>{"use strict";e.exports=r},667:e=>{"use strict";e.exports=M},606:e=>{"use strict";e.exports=v},746:e=>{"use strict";e.exports=N}},D={};function C(e){var t=D[e];if(void 0!==t)return t.exports;var i=D[e]={exports:{}};return b[e](i,i.exports,C),i.exports}C.d=(e,t)=>{for(var i in t)C.o(t,i)&&!C.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},C.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),C.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var L={};return(()=>{"use strict";C.r(L),C.d(L,{BoneNotFoundError:()=>e,HumanoidBone:()=>t,IVRMMaterialPropertyShader:()=>d,MaterialValueBindingMerger:()=>h,VCAST_vci_material_unity:()=>g,VRM:()=>w,VRMFileLoader:()=>U,VRMManager:()=>R,VRMMaterialGenerator:()=>c});class e extends Error{constructor(e){super(`Bone:${e} NotFound`),this.boneName=e,this.name="BoneNotFoundError"}}class t{constructor(e){this.nodeMap=e}dispose(){this.nodeMap=null}get hips(){return this.getMandatoryBone("hips")}get leftUpperLeg(){return this.getMandatoryBone("leftUpperLeg")}get rightUpperLeg(){return this.getMandatoryBone("rightUpperLeg")}get leftLowerLeg(){return this.getMandatoryBone("leftLowerLeg")}get rightLowerLeg(){return this.getMandatoryBone("rightLowerLeg")}get leftFoot(){return this.getMandatoryBone("leftFoot")}get rightFoot(){return this.getMandatoryBone("rightFoot")}get spine(){return this.getMandatoryBone("spine")}get chest(){return this.getMandatoryBone("chest")}get neck(){return this.getMandatoryBone("neck")}get head(){return this.getMandatoryBone("head")}get leftShoulder(){return this.getMandatoryBone("leftShoulder")}get rightShoulder(){return this.getMandatoryBone("rightShoulder")}get leftUpperArm(){return this.getMandatoryBone("leftUpperArm")}get rightUpperArm(){return this.getMandatoryBone("rightUpperArm")}get leftLowerArm(){return this.getMandatoryBone("leftLowerArm")}get rightLowerArm(){return this.getMandatoryBone("rightLowerArm")}get leftHand(){return this.getMandatoryBone("leftHand")}get rightHand(){return this.getMandatoryBone("rightHand")}get leftToes(){return this.getOptionalBone("leftToes")}get rightToes(){return this.getOptionalBone("rightToes")}get leftEye(){return this.getOptionalBone("leftEye")}get rightEye(){return this.getOptionalBone("rightEye")}get jaw(){return this.getOptionalBone("jaw")}get leftThumbProximal(){return this.getOptionalBone("leftThumbProximal")}get leftThumbIntermediate(){return this.getOptionalBone("leftThumbIntermediate")}get leftThumbDistal(){return this.getOptionalBone("leftThumbDistal")}get leftIndexProximal(){return this.getOptionalBone("leftIndexProximal")}get leftIndexIntermediate(){return this.getOptionalBone("leftIndexIntermediate")}get leftIndexDistal(){return this.getOptionalBone("leftIndexDistal")}get leftMiddleProximal(){return this.getOptionalBone("leftMiddleProximal")}get leftMiddleIntermediate(){return this.getOptionalBone("leftMiddleIntermediate")}get leftMiddleDistal(){return this.getOptionalBone("leftMiddleDistal")}get leftRingProximal(){return this.getOptionalBone("leftRingProximal")}get leftRingIntermediate(){return this.getOptionalBone("leftRingIntermediate")}get leftRingDistal(){return this.getOptionalBone("leftRingDistal")}get leftLittleProximal(){return this.getOptionalBone("leftLittleProximal")}get leftLittleIntermediate(){return this.getOptionalBone("leftLittleIntermediate")}get leftLittleDistal(){return this.getOptionalBone("leftLittleDistal")}get rightThumbProximal(){return this.getOptionalBone("rightThumbProximal")}get rightThumbIntermediate(){return this.getOptionalBone("rightThumbIntermediate")}get rightThumbDistal(){return this.getOptionalBone("rightThumbDistal")}get rightIndexProximal(){return this.getOptionalBone("rightIndexProximal")}get rightIndexIntermediate(){return this.getOptionalBone("rightIndexIntermediate")}get rightIndexDistal(){return this.getOptionalBone("rightIndexDistal")}get rightMiddleProximal(){return this.getOptionalBone("rightMiddleProximal")}get rightMiddleIntermediate(){return this.getOptionalBone("rightMiddleIntermediate")}get rightMiddleDistal(){return this.getOptionalBone("rightMiddleDistal")}get rightRingProximal(){return this.getOptionalBone("rightRingProximal")}get rightRingIntermediate(){return this.getOptionalBone("rightRingIntermediate")}get rightRingDistal(){return this.getOptionalBone("rightRingDistal")}get rightLittleProximal(){return this.getOptionalBone("rightLittleProximal")}get rightLittleIntermediate(){return this.getOptionalBone("rightLittleIntermediate")}get rightLittleDistal(){return this.getOptionalBone("rightLittleDistal")}get upperChest(){return this.getOptionalBone("upperChest")}getMandatoryBone(t){const i=this.nodeMap[t];if(!i)throw new e(t);return i}getOptionalBone(e){return this.nodeMap&&this.nodeMap[e]||null}}var i=C(197),n=C(235),r=C(838);const a={_MainTex:"albedoTexture"},o={_Color:"albedoColor"},s={_MainTex:"diffuseTexture",_EmissionMap:"emissiveTexture",_BumpMap:"bumpTexture",_ShadeTexture:"shadeTexture",_ReceiveShadowTexture:"receiveShadowTexture",_ShadingGradeTexture:"shadingGradeTexture",_RimTexture:"rimTexture",_SphereAdd:"matCapTexture",_OutlineWidthTexture:"outlineWidthTexture",_UvAnimMaskTexture:"uvAnimationMaskTexture"},l={_Color:"diffuseColor",_ShadeColor:"shadeColor",_RimColor:"rimColor",_EmissionColor:"emissiveColor",_OutlineColor:"outlineColor"};class h{constructor(e,t){this.materialValues=t,this.m_materialMap={},this.m_materialSetterMap={},this.m_materialValueMap={},this.m_used={},this.baseValueCache={},this.materialValuesToApply={},0!==e.length&&0!==t.length&&(e.forEach((e=>{(e instanceof r.MToonMaterial||e instanceof n.PBRMaterial)&&(this.m_materialMap[e.name]=e)})),t.forEach((e=>{const t=this.makeBindingKey(e);if(this.m_materialSetterMap[t])return;const r=this.m_materialMap[e.materialName];if(!r)return;const o=this.getMaterialProperty(r,e.propertyName);if(!o||4!==e.targetValue.length)return;this.baseValueCache[t]=o,this.materialValuesToApply[t]=e;const l=i.Vector4.FromArray(e.targetValue),h=e.propertyName;if(r instanceof n.PBRMaterial?Object.keys(a).some((e=>h.startsWith(e)))&&(l.w*=-1):Object.keys(s).some((e=>h.startsWith(e)))&&(l.w*=-1),h.endsWith("_ST_S")){const e=(e,t)=>{const i=t?o.add(l.subtract(o).scale(e)):this.getMaterialProperty(r,h).add(l.subtract(o).scale(e)),n=this.getMaterialProperty(r,h);n.x=i.x,n.z=i.z,this.updateMaterialProperty(r,h,n)};this.m_materialSetterMap[t]=e}else if(h.endsWith("_ST_T")){const e=(e,t)=>{const i=t?o.add(l.subtract(o).scale(e)):this.getMaterialProperty(r,h).add(l.subtract(o).scale(e)),n=this.getMaterialProperty(r,h);n.y=i.y,n.w=i.w,this.updateMaterialProperty(r,h,n)};this.m_materialSetterMap[t]=e}else{const e=(e,t)=>{const i=t?o.add(l.subtract(o).scale(e)):this.getMaterialProperty(r,h).add(l.subtract(o).scale(e));this.updateMaterialProperty(r,h,i)};this.m_materialSetterMap[t]=e}})))}makeBindingKey(e){return`${e.materialName}_${e.propertyName}_${e.targetValue.join("-")}`}makeTargetKey(e){return`${e.materialName}_${e.propertyName}`}morphing(e){this.accumulateValue(e),this.apply()}accumulateValue(e){this.materialValues.forEach((t=>{const i=this.makeBindingKey(t);this.m_materialValueMap[i]?this.m_materialValueMap[i]+=e:this.m_materialValueMap[i]=e}))}apply(){this.m_used={},Object.entries(this.materialValuesToApply).forEach((([e,t])=>{const i=this.makeTargetKey(t);if(!(i in this.m_used)){const n=this.m_materialMap[t.materialName],r=this.baseValueCache[e].clone(),a=t.propertyName;if(a.endsWith("_ST_S")){const e=this.getMaterialProperty(n,a);r.y=e.y,r.w=e.w}else if(a.endsWith("_ST_T")){const e=this.getMaterialProperty(n,a);r.x=e.x,r.z=e.z}this.updateMaterialProperty(n,a,r),this.m_used[i]=!0}const n=this.m_materialSetterMap[e];n&&n(this.m_materialValueMap[e],!1)})),this.m_materialValueMap={}}getMaterialProperty(e,t){const i=t.match(/^(_[^_]+)/);if(!i||!i[1])return null;const r=i[1];return e instanceof n.PBRMaterial?a[r]?this.convertTextureIntoVector4WhenNotNull(e[a[r]]):o[r]?this.convertColorIntoVector4(e[o[r]],e.alpha):null:s[r]?this.convertTextureIntoVector4WhenNotNull(e[s[r]]):l[r]?this.convertColorIntoVector4(e[l[r]],e.alpha):null}convertTextureIntoVector4WhenNotNull(e){if(!e)return null;const t=e;return new i.Vector4(t.uScale,t.vScale,t.uOffset,t.vOffset)}convertColorIntoVector4(e,t){return new i.Vector4(e.r,e.g,e.b,t)}updateMaterialProperty(e,t,i){const r=t.match(/^(_[^_]+)/);if(!r||!r[1])return;const h=r[1];if(e instanceof n.PBRMaterial)return a[h]?void this.updateTextureWhenNotNull(e[a[h]],i):void(o[h]&&("_Color"===h&&(e.alpha=i.w),this.updateColor(e[o[h]],i)));s[h]?this.updateTextureWhenNotNull(e[s[h]],i):l[h]&&("_Color"===h&&(e.alpha=i.w),this.updateColor(e[l[h]],i))}updateTextureWhenNotNull(e,t){if(e){const i=e;i.uScale=t.x,i.vScale=t.y,i.uOffset=t.z,i.vOffset=t.w}}updateColor(e,t){e.r=t.x,e.g=t.y,e.b=t.z}}var d,u=C(606);!function(e){e.VRM_USE_GLTFSHADER="VRM_USE_GLTFSHADER",e.VRMMToon="VRM/MToon",e.VRMUnlitTransparentZWrite="VRM/UnlitTransparentZWrite"}(d||(d={}));var f=C(4);class c{constructor(e){this.loader=e}generate(e,t,i,n,a){const o=this.findMaterialPropertyByName(t.name,this.getMaterialProperties());if(!o)return null;i.alphaIndex=o.renderQueue;const s=this.createMaterialByShader(e,t,n,o);return s?(a(s),s instanceof r.MToonMaterial?this.loadMToonTexturesAsync(e,s,o):Promise.resolve(s)):null}getMaterialProperties(){return this.loader.gltf.extensions?this.loader.gltf.extensions.VRM&&this.loader.gltf.extensions.VRM.materialProperties?this.loader.gltf.extensions.VRM.materialProperties:this.loader.gltf.extensions.VCAST_vci_material_unity&&this.loader.gltf.extensions.VCAST_vci_material_unity.materials?this.loader.gltf.extensions.VCAST_vci_material_unity.materials:[]:[]}findMaterialPropertyByName(e,t){if(!e||!t)return null;const i=t.filter((t=>t.name===e));return 0===i.length?null:(i.length>=2&&this.loader.log(`Duplicated vrm material name found: ${e}`),i[i.length-1])}loadMToonTexturesAsync(e,t,i){const n=[],r=i.vectorProperties._MainTex;if(!r)return Promise.resolve(t);const a=(t,i)=>{m(t,(a=>{n.push(this.loader.loadTextureInfoAsync(`${e}/textures/${t}`,{index:a},(e=>{const t=e;t.uOffset=r[0],t.vOffset=r[1],t.uScale=r[2],t.vScale=r[3],i(e)})))}))};return a(i.textureProperties._MainTex,(e=>{(t.alphaBlend||t.alphaTest)&&(e.hasAlpha=!0),t.diffuseTexture=e})),a(i.textureProperties._ShadeTexture,(e=>t.shadeTexture=e)),a(i.textureProperties._BumpMap,(e=>t.bumpTexture=e)),a(i.textureProperties._ReceiveShadowTexture,(e=>t.receiveShadowTexture=e)),a(i.textureProperties._ShadingGradeTexture,(e=>t.shadingGradeTexture=e)),a(i.textureProperties._RimTexture,(e=>t.rimTexture=e)),a(i.textureProperties._SphereAdd,(e=>t.matCapTexture=e)),a(i.textureProperties._EmissionMap,(e=>t.emissiveTexture=e)),a(i.textureProperties._OutlineWidthTexture,(e=>t.outlineWidthTexture=e)),a(i.textureProperties._UvAnimMaskTexture,(e=>t.uvAnimationMaskTexture=e)),Promise.all(n).then((()=>t))}createMaterialByShader(e,t,i,n){if(n.shader===d.VRMMToon){const e=new r.MToonMaterial(t.name||`MToonMaterial${t.index}`,this.loader.babylonScene);return this.setMToonMaterialProperties(e,n),e}if(n.shader===d.VRMUnlitTransparentZWrite){const n=this.loader.createMaterial(e,t,i);return n.disableDepthWrite=!1,n.forceDepthWrite=!0,n}return null}setMToonMaterialProperties(e,t){m(t.floatProperties._Cutoff,(t=>e.alphaCutOff=t)),m(t.vectorProperties._Color,(t=>{e.diffuseColor=new i.Color3(t[0],t[1],t[2]),e.alpha=t[3]})),m(t.vectorProperties._ShadeColor,(t=>{e.shadeColor=new i.Color3(t[0],t[1],t[2])})),m(t.floatProperties._BumpScale,(t=>e.bumpScale=t)),m(t.floatProperties._ReceiveShadowRate,(t=>e.receiveShadowRate=t)),m(t.floatProperties._ShadingGradeRate,(t=>e.shadingGradeRate=t)),m(t.floatProperties._ShadeShift,(t=>e.shadeShift=t)),m(t.floatProperties._ShadeToony,(t=>e.shadeToony=t)),m(t.floatProperties._LightColorAttenuation,(t=>e.lightColorAttenuation=t)),m(t.floatProperties._IndirectLightIntensity,(t=>e.indirectLightIntensity=t)),m(t.vectorProperties._RimColor,(t=>{e.rimColor=new i.Color3(t[0],t[1],t[2])})),m(t.floatProperties._RimLightingMix,(t=>e.rimLightingMix=t)),m(t.floatProperties._RimFresnelPower,(t=>e.rimFresnelPower=t)),m(t.floatProperties._RimLift,(t=>e.rimLift=t)),m(t.vectorProperties._EmissionColor,(t=>{e.emissiveColor=new i.Color3(t[0],t[1],t[2])})),m(t.floatProperties._OutlineWidth,(t=>e.outlineWidth=t)),m(t.floatProperties._OutlineScaledMaxDistance,(t=>e.outlineScaledMaxDistance=t)),m(t.vectorProperties._OutlineColor,(t=>{e.outlineColor=new i.Color3(t[0],t[1],t[2])})),m(t.floatProperties._OutlineLightingMix,(t=>e.outlineLightingMix=t)),m(t.floatProperties._UvAnimScrollX,(t=>e.uvAnimationScrollX=t)),m(t.floatProperties._UvAnimScrollY,(t=>e.uvAnimationScrollY=t)),m(t.floatProperties._UvAnimRotation,(t=>e.uvAnimationRotation=t)),m(t.floatProperties._DebugMode,(t=>e.debugMode=t)),m(t.floatProperties._BlendMode,(t=>{switch(t){case 0:e.alphaBlend=!1,e.alphaTest=!1;break;case 1:e.alphaBlend=!1,e.alphaTest=!0,e.alphaMode=f.Engine.ALPHA_COMBINE;break;case 2:e.alphaBlend=!0,e.alphaTest=!1,e.alphaMode=f.Engine.ALPHA_COMBINE}})),m(t.floatProperties._OutlineWidthMode,(t=>e.outlineWidthMode=t)),m(t.floatProperties._OutlineColorMode,(t=>e.outlineColorMode=t)),m(t.floatProperties._CullMode,(t=>e.cullMode=t)),m(t.floatProperties._OutlineCullMode,(t=>e.outlineCullMode=t)),m(t.keywordMap._ALPHABLEND_ON,(t=>e.alphaBlend=t)),m(t.keywordMap._ALPHATEST_ON,(t=>e.alphaTest=t)),m(t.floatProperties._ZWrite,(t=>{e.forceDepthWrite=1===Math.round(t),e.forceDepthWrite&&(e.disableDepthWrite=!1)}))}}function m(e,t){void 0!==e&&t(e)}const p="VCAST_vci_material_unity";class g{constructor(e){this.loader=e,this.name=p,this.enabled=!0}dispose(){this.loader=null}_loadMaterialAsync(e,t,i,n,r){return new c(this.loader).generate(e,t,i,n,r)}}u.GLTFLoader.RegisterExtension(p,(e=>new g(e)));var _=C(705);class M{constructor(e,t,i){this.offset=e,this.radius=t,this.sphere=i}}class A{constructor(e){this.transform=e,this.colliders=[]}addCollider(e,t){const i=_.SphereBuilder.CreateSphere(`${this.transform.name}_ColliderSphere`,{segments:6,diameter:2*t,updatable:!0},this.transform.getScene());i.setParent(this.transform),i.setPositionWithLocalVector(e),i.setEnabled(!1),this.colliders.push(new M(e,t,i))}}var v=C(53),T=C(564);const I=i.Matrix.Identity(),S=new i.Vector3,E=new i.Vector3,x=new i.Vector3,N=new i.Quaternion,b=new i.Matrix,D=new i.Matrix;class P{constructor(e,t,n){this.center=e,this.radius=t,this.transform=n,this.currentTail=new i.Vector3,this.prevTail=new i.Vector3,this.nextTail=new i.Vector3,n.rotationQuaternion||(n.rotationQuaternion=n.rotation.toQuaternion());const r=n.getWorldMatrix();this.centerSpacePosition=r.getTranslation(),this.initialLocalMatrix=n._localMatrix.clone(),this.initialLocalRotation=n.rotationQuaternion.clone();const a=n.getChildTransformNodes(!0);0===a.length?this.initialLocalChildPosition=n.position.clone().normalize().scaleInPlace(.07):this.initialLocalChildPosition=a[0].position.clone(),i.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,r,this.currentTail),this.prevTail.copyFrom(this.currentTail),this.nextTail.copyFrom(this.currentTail),this.boneAxis=this.initialLocalChildPosition.normalizeToNew(),i.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,r,S),this.centerSpaceBoneLength=S.subtractInPlace(this.centerSpacePosition).length(),e&&(this.getMatrixWorldToCenter(b),i.Vector3.TransformCoordinatesToRef(this.currentTail,b,this.currentTail),i.Vector3.TransformCoordinatesToRef(this.prevTail,b,this.prevTail),i.Vector3.TransformCoordinatesToRef(this.nextTail,b,this.nextTail),r.multiplyToRef(b,b),b.getTranslationToRef(this.centerSpacePosition),i.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,b,S),this.centerSpaceBoneLength=S.subtractInPlace(this.centerSpacePosition).length())}update(e,t,n,r){if(Number.isNaN(this.transform.getAbsolutePosition().x))return;this.getMatrixWorldToCenter(b),this.transform.getWorldMatrix().multiplyToRef(b,b),b.getTranslationToRef(this.centerSpacePosition),this.getMatrixWorldToCenter(D),this.getParentMatrixWorld().multiplyToRef(D,D),this.nextTail.copyFrom(this.currentTail),S.copyFrom(this.currentTail).subtractInPlace(this.prevTail).scaleInPlace(1-t),this.nextTail.addInPlace(S),S.copyFrom(this.boneAxis),i.Vector3.TransformCoordinatesToRef(S,this.initialLocalMatrix,S),i.Vector3.TransformCoordinatesToRef(S,D,S),S.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(e),this.nextTail.addInPlace(S),this.nextTail.addInPlace(n),this.nextTail.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition),this.collide(r,this.nextTail),this.prevTail.copyFrom(this.currentTail),this.currentTail.copyFrom(this.nextTail),this.initialLocalMatrix.multiplyToRef(D,b);const a=b.invert();i.Vector3.TransformCoordinatesToRef(this.nextTail,a,S),S.normalizeToRef(E),i.Quaternion.FromUnitVectorsToRef(this.boneAxis,E,N);const o=N;this.initialLocalRotation.multiplyToRef(o,this.transform.rotationQuaternion),this.transform.computeWorldMatrix(!0)}getMatrixWorldToCenter(e){return this.center?this.center.getWorldMatrix().invertToRef(e):e.copyFrom(I),e}getParentMatrixWorld(){return this.transform.parent?this.transform.parent.getWorldMatrix():I}collide(e,t){e.forEach((e=>{e.colliders.forEach((e=>{this.getMatrixWorldToCenter(b),e.sphere.computeWorldMatrix().multiplyToRef(b,b),b.getTranslationToRef(S);const i=S;let n=0;e.sphere.absoluteScaling.asArray().forEach((e=>{n=Math.max(n,Math.abs(e))}));const r=e.radius*n,a=this.radius+r;if(t.subtractToRef(i,E),E.lengthSquared()<=a*a){const e=E.copyFrom(t).subtractInPlace(i).normalize(),n=x.copyFrom(i).addInPlace(e.scaleInPlace(a));t.copyFrom(n.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition))}}))}))}}class y{constructor(e,t,i,n,r,a,o,s,l){this.comment=e,this.stiffness=t,this.gravityPower=i,this.gravityDir=n,this.dragForce=r,this.center=a,this.hitRadius=o,this.bones=s,this.colliderGroups=l,this.verlets=[],this.activeBones=[],this.drawGizmo=!1,this.activeBones=this.bones.filter((e=>null!==e)),this.activeBones.forEach((e=>{[e].concat(e.getChildTransformNodes()).forEach((e=>{this.verlets.push(new P(this.center,this.hitRadius,e))}))})),this.drawGizmo&&this.setupGizmo()}setupGizmo(){this.activeBones.forEach((e=>{const t=e.getScene();[e].concat(e.getChildTransformNodes()).forEach((e=>{const n=T.MeshBuilder.CreateSphere(e.name+"_boneGizmo",{segments:6,diameter:2*this.hitRadius,updatable:!0},t),r=new v.StandardMaterial(e.name+"_boneGizmomat",t);r.emissiveColor=i.Color3.Red(),r.wireframe=!0,n.material=r,n.setParent(e),n.position=i.Vector3.Zero()}))})),this.colliderGroups.forEach((e=>{const t=e.transform.getScene();e.colliders.forEach((n=>{const r=n.sphere;if(!r.isEnabled(!1)){r.setEnabled(!0);const n=new v.StandardMaterial(e.transform.name+"_colliderGizmomat",t);n.emissiveColor=i.Color3.Yellow(),n.wireframe=!0,r.material=n}}))}))}async update(e){const t=this.stiffness*e,i=this.gravityDir.scale(this.gravityPower*e),n=this.verlets.map((e=>new Promise((n=>{e.update(t,this.dragForce,i,this.colliderGroups),n()}))));return Promise.all(n).then((()=>{}))}}class O{constructor(e,t){this.ext=e;const i=this.constructColliderGroups(t);this.springs=this.constructSprings(t,i)}dispose(){this.springs=[]}async update(e){e=Math.max(0,Math.min(16.666,e))/1e3;const t=this.springs.map((t=>t.update(e)));return Promise.all(t).then((()=>{}))}constructColliderGroups(e){if(!this.ext.colliderGroups||!this.ext.colliderGroups.length)return[];const t=[];return this.ext.colliderGroups.forEach((n=>{const r=e(n.node),a=new A(r);n.colliders.forEach((e=>{a.addCollider(new i.Vector3(-e.offset.x,e.offset.y,-e.offset.z),e.radius)})),t.push(a)})),t}constructSprings(e,t){if(!this.ext.boneGroups||!this.ext.boneGroups.length)return[];const n=[];return this.ext.boneGroups.forEach((r=>{const a=(r.bones||[]).map((t=>e(t))),o=(r.colliderGroups||[]).map((e=>t[e]));n.push(new y(r.comment,r.stiffiness,r.gravityPower,new i.Vector3(-r.gravityDir.x,r.gravityDir.y,-r.gravityDir.z).normalize(),r.dragForce,e(r.center),r.hitRadius,a,o))})),n}}class R{constructor(e,i,n,r,a){this.ext=e,this.scene=i,this.meshesFrom=n,this.transformNodesFrom=r,this.materialsNodesFrom=a,this.isBinaryMorphMap={},this.morphTargetMap={},this.materialValueBindingMergerMap={},this.presetMorphTargetMap={},this.transformNodeMap={},this.transformNodeCache={},this.meshCache={},this.meshCache=this.constructMeshCache(),this.transformNodeCache=this.constructTransformNodeCache(),this.springBoneController=new O(this.ext.secondaryAnimation,this.findTransformNode.bind(this)),this.ext.blendShapeMaster&&this.ext.blendShapeMaster.blendShapeGroups&&(this.constructIsBinaryMap(),this.constructMorphTargetMap(),this.constructMaterialValueBindingMergerMap()),this.constructTransformNodeMap(),this._humanoidBone=new t(this.transformNodeMap)}async update(e){await this.springBoneController.update(e)}dispose(){this.springBoneController.dispose(),this._humanoidBone.dispose(),this.morphTargetMap=null,this.materialValueBindingMergerMap=null,this.presetMorphTargetMap=null,this.transformNodeMap=null,this.transformNodeCache=null,this.meshCache=null,this._rootMesh=null}morphing(e,t){const i=this.calcMorphValue(e,t);this.morphTargetMap[e]&&this.morphTargetMap[e].forEach((e=>{e.target.influence=i*(e.weight/100)})),this.materialValueBindingMergerMap[e]&&this.materialValueBindingMergerMap[e].morphing(i)}morphingPreset(e,t){if(!this.presetMorphTargetMap[e])return;const i=this.calcMorphValue(e,t);this.presetMorphTargetMap[e].forEach((e=>{e.target.influence=i*(e.weight/100)}))}calcMorphValue(e,t){const i=Math.max(0,Math.min(1,t));return this.isBinaryMorphMap[e]?i>.5?1:0:i}getMorphingList(){return Object.keys(this.morphTargetMap)}getFirstPersonCameraPosition(){const e=this.getFirstPersonBone();if(!e)return null;const t=e.getAbsolutePosition(),n=this.ext.firstPerson.firstPersonBoneOffset;return new i.Vector3(t.x+n.x,t.y+n.y,t.z+n.z)}getFirstPersonBone(){return this.findTransformNode(this.ext.firstPerson.firstPersonBone)}getBone(e){return this.transformNodeMap[e]||null}get humanoidBone(){return this._humanoidBone}get rootMesh(){return this._rootMesh}findTransformNode(e){return this.transformNodeCache[e]||null}findMesh(e){return this.meshCache[e]&&this.meshCache[e][0]||null}findMeshes(e){return this.meshCache[e]||null}constructIsBinaryMap(){this.ext.blendShapeMaster.blendShapeGroups.forEach((e=>{this.isBinaryMorphMap[e.name]=e.isBinary}))}constructMorphTargetMap(){this.ext.blendShapeMaster.blendShapeGroups.forEach((e=>{e.binds&&e.binds.forEach((t=>{const i=this.findMeshes(t.mesh);i?i.forEach((i=>{const n=i.morphTargetManager;if(!n)return void console.log("Undefined morphTargetManager",t);const r=n.getTarget(t.index);this.morphTargetMap[e.name]=this.morphTargetMap[e.name]||[],this.morphTargetMap[e.name].push({target:r,weight:t.weight}),e.presetName&&(this.presetMorphTargetMap[e.presetName]=this.presetMorphTargetMap[e.presetName]||[],this.presetMorphTargetMap[e.presetName].push({target:r,weight:t.weight}))})):console.log("Undefined BlendShapeBind Mesh",t)}))}))}constructMaterialValueBindingMergerMap(){const e=this.scene.materials.slice(this.materialsNodesFrom);this.ext.blendShapeMaster.blendShapeGroups.forEach((t=>{t.materialValues&&(this.materialValueBindingMergerMap[t.name]=new h(e,t.materialValues))}))}constructTransformNodeMap(){this.ext.humanoid.humanBones.forEach((e=>{const t=this.findTransformNode(e.node);t&&(this.transformNodeMap[e.bone]=t)}))}constructTransformNodeCache(){const e={};for(let t=this.transformNodesFrom;t<this.scene.transformNodes.length;t++){const i=this.scene.transformNodes[t];if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers)if(t.startsWith("/nodes/")){e[parseInt(t.substr(7),10)]=i;break}}return e}constructMeshCache(){const e={};for(let t=this.meshesFrom;t<this.scene.meshes.length;t++){const i=this.scene.meshes[t];if("__root__"!==i.id){if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers){const n=t.match(/^\/meshes\/(\d+).+$/);if(n){const t=parseInt(n[1],10);e[t]=e[t]||[],e[t].push(i);break}}}else this._rootMesh=i}return e}}class w{constructor(e){this.loader=e,this.name="VRM",this.enabled=!0,this.meshesFrom=0,this.transformNodesFrom=0,this.materialsFrom=0,this.meshesFrom=this.loader.babylonScene.meshes.length-1,this.transformNodesFrom=this.loader.babylonScene.transformNodes.length,this.materialsFrom=this.loader.babylonScene.materials.length}dispose(){this.loader=null}onReady(){if(!this.loader.gltf.extensions||!this.loader.gltf.extensions.VRM)return;const e=this.loader.babylonScene,t=new R(this.loader.gltf.extensions.VRM,this.loader.babylonScene,this.meshesFrom,this.transformNodesFrom,this.materialsFrom);e.metadata=e.metadata||{},e.metadata.vrmManagers=e.metadata.vrmManagers||[],e.metadata.vrmManagers.push(t),this.loader.babylonScene.onDisposeObservable.add((()=>{t.dispose(),this.loader.babylonScene.metadata.vrmManagers=[]}))}_loadVertexDataAsync(e,t,i){return t.extras&&t.extras.targetNames?(i.metadata=i.metadata||{},i.metadata.vrmTargetNames=t.extras.targetNames,null):null}_loadMaterialAsync(e,t,i,n,r){return new c(this.loader).generate(e,t,i,n,r)}}u.GLTFLoader.RegisterExtension("VRM",(e=>new w(e)));var F=C(6),X=C(746);class U extends X.GLTFFileLoader{constructor(){super(...arguments),this.name="vrm",this.extensions={".vrm":{isBinary:!0},".vci":{isBinary:!0}}}createPlugin(){return new U}}F.SceneLoader&&F.SceneLoader.RegisterPlugin(new U)})(),L})()));
\ No newline at end of file
+!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@bbl5.25.0/core/Maths/math"),require("@bbl5.25.0/core"),require("@bbl5.25.0/core/Misc/decorators"),require("@bbl5.25.0/core/Misc/smartArray"),require("@bbl5.25.0/core/scene"),require("@bbl5.25.0/core/Maths/math.vector"),require("@bbl5.25.0/core/Maths/math.color"),require("@bbl5.25.0/core/Buffers/buffer"),require("@bbl5.25.0/core/Materials/imageProcessingConfiguration"),require("@bbl5.25.0/core/Materials/material"),require("@bbl5.25.0/core/Materials/pushMaterial"),require("@bbl5.25.0/core/Materials/materialHelper"),require("@bbl5.25.0/core/Engines/constants"),require("@bbl5.25.0/core/Materials/effectFallbacks"),require("@bbl5.25.0/core/Materials/effect"),require("@bbl5.25.0/core/Materials/material.detailMapConfiguration"),require("@bbl5.25.0/core/Materials/materialPluginEvent"),require("@bbl5.25.0/core/Misc/iInspectable"),require("@bbl5.25.0/core/sceneComponent"),require("@bbl5.25.0/core/Materials/materialDefines"),require("@bbl5.25.0/loaders/glTF/2.0"),require("@bbl5.25.0/core/Engines/engine"),require("@bbl5.25.0/core/Meshes/Builders/sphereBuilder"),require("@bbl5.25.0/core/Materials/standardMaterial"),require("@bbl5.25.0/core/Meshes/meshBuilder"),require("@bbl5.25.0/core/Loading/sceneLoader"),require("@bbl5.25.0/loaders/glTF/glTFFileLoader")):"function"==typeof define&&define.amd?define(["@bbl5.25.0/core/Maths/math","@bbl5.25.0/core","@bbl5.25.0/core/Misc/decorators","@bbl5.25.0/core/Misc/smartArray","@bbl5.25.0/core/scene","@bbl5.25.0/core/Maths/math.vector","@bbl5.25.0/core/Maths/math.color","@bbl5.25.0/core/Buffers/buffer","@bbl5.25.0/core/Materials/imageProcessingConfiguration","@bbl5.25.0/core/Materials/material","@bbl5.25.0/core/Materials/pushMaterial","@bbl5.25.0/core/Materials/materialHelper","@bbl5.25.0/core/Engines/constants","@bbl5.25.0/core/Materials/effectFallbacks","@bbl5.25.0/core/Materials/effect","@bbl5.25.0/core/Materials/material.detailMapConfiguration","@bbl5.25.0/core/Materials/materialPluginEvent","@bbl5.25.0/core/Misc/iInspectable","@bbl5.25.0/core/sceneComponent","@bbl5.25.0/core/Materials/materialDefines","@bbl5.25.0/loaders/glTF/2.0","@bbl5.25.0/core/Engines/engine","@bbl5.25.0/core/Meshes/Builders/sphereBuilder","@bbl5.25.0/core/Materials/standardMaterial","@bbl5.25.0/core/Meshes/meshBuilder","@bbl5.25.0/core/Loading/sceneLoader","@bbl5.25.0/loaders/glTF/glTFFileLoader"],t):"object"==typeof exports?exports["babylon-vrm-loader"]=t(require("@bbl5.25.0/core/Maths/math"),require("@bbl5.25.0/core"),require("@bbl5.25.0/core/Misc/decorators"),require("@bbl5.25.0/core/Misc/smartArray"),require("@bbl5.25.0/core/scene"),require("@bbl5.25.0/core/Maths/math.vector"),require("@bbl5.25.0/core/Maths/math.color"),require("@bbl5.25.0/core/Buffers/buffer"),require("@bbl5.25.0/core/Materials/imageProcessingConfiguration"),require("@bbl5.25.0/core/Materials/material"),require("@bbl5.25.0/core/Materials/pushMaterial"),require("@bbl5.25.0/core/Materials/materialHelper"),require("@bbl5.25.0/core/Engines/constants"),require("@bbl5.25.0/core/Materials/effectFallbacks"),require("@bbl5.25.0/core/Materials/effect"),require("@bbl5.25.0/core/Materials/material.detailMapConfiguration"),require("@bbl5.25.0/core/Materials/materialPluginEvent"),require("@bbl5.25.0/core/Misc/iInspectable"),require("@bbl5.25.0/core/sceneComponent"),require("@bbl5.25.0/core/Materials/materialDefines"),require("@bbl5.25.0/loaders/glTF/2.0"),require("@bbl5.25.0/core/Engines/engine"),require("@bbl5.25.0/core/Meshes/Builders/sphereBuilder"),require("@bbl5.25.0/core/Materials/standardMaterial"),require("@bbl5.25.0/core/Meshes/meshBuilder"),require("@bbl5.25.0/core/Loading/sceneLoader"),require("@bbl5.25.0/loaders/glTF/glTFFileLoader")):e["babylon-vrm-loader"]=t(e["@bbl5.25.0/core/Maths/math"],e["@bbl5.25.0/core"],e["@bbl5.25.0/core/Misc/decorators"],e["@bbl5.25.0/core/Misc/smartArray"],e["@bbl5.25.0/core/scene"],e["@bbl5.25.0/core/Maths/math.vector"],e["@bbl5.25.0/core/Maths/math.color"],e["@bbl5.25.0/core/Buffers/buffer"],e["@bbl5.25.0/core/Materials/imageProcessingConfiguration"],e["@bbl5.25.0/core/Materials/material"],e["@bbl5.25.0/core/Materials/pushMaterial"],e["@bbl5.25.0/core/Materials/materialHelper"],e["@bbl5.25.0/core/Engines/constants"],e["@bbl5.25.0/core/Materials/effectFallbacks"],e["@bbl5.25.0/core/Materials/effect"],e["@bbl5.25.0/core/Materials/material.detailMapConfiguration"],e["@bbl5.25.0/core/Materials/materialPluginEvent"],e["@bbl5.25.0/core/Misc/iInspectable"],e["@bbl5.25.0/core/sceneComponent"],e["@bbl5.25.0/core/Materials/materialDefines"],e["@bbl5.25.0/loaders/glTF/2.0"],e["@bbl5.25.0/core/Engines/engine"],e["@bbl5.25.0/core/Meshes/Builders/sphereBuilder"],e["@bbl5.25.0/core/Materials/standardMaterial"],e["@bbl5.25.0/core/Meshes/meshBuilder"],e["@bbl5.25.0/core/Loading/sceneLoader"],e["@bbl5.25.0/loaders/glTF/glTFFileLoader"])}(self,((e,t,i,n,r,a,o,s,l,h,d,u,f,c,m,p,g,_,M,A,v,T,I,S,E,x,N)=>(()=>{var b={838:(e,t,i)=>{var n;self,n=(e,t,i,n,r,a,o,s,l,h,d,u,f,c,m,p,g,_)=>(()=>{"use strict";var M={908:e=>{e.exports=a},556:e=>{e.exports=d},272:e=>{e.exports=f},55:e=>{e.exports=u},677:e=>{e.exports=o},66:e=>{e.exports=s},824:e=>{e.exports=c},713:e=>{e.exports=_},221:e=>{e.exports=h},628:e=>{e.exports=m},721:e=>{e.exports=l},548:e=>{e.exports=r},694:e=>{e.exports=n},388:t=>{t.exports=e},812:e=>{e.exports=p},474:e=>{e.exports=t},538:e=>{e.exports=i},667:e=>{e.exports=g}},A={};function v(e){var t=A[e];if(void 0!==t)return t.exports;var i=A[e]={exports:{}};return M[e](i,i.exports,v),i.exports}v.d=(e,t)=>{for(var i in t)v.o(t,i)&&!v.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},v.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),v.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var T={};return(()=>{function e(e,t,i,n){var r,a=arguments.length,o=a<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,i,n);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(a<3?r(o):a>3?r(t,i,o):r(t,i))||o);return a>3&&o&&Object.defineProperty(t,i,o),o}v.r(T),v.d(T,{CullMode:()=>b,DebugMode:()=>E,MToonMaterial:()=>D,OutlineColorMode:()=>x,OutlineWidthMode:()=>N}),Object.create,Object.create;var t=v(388),i=v(474),n=v(538),r=v(694),a=v(548),o=v(908),s=v(677),l=v(66),h=v(721),d=v(221),u=v(556),f=v(55),c=v(272),m=v(824),p=v(628),g=v(812),_=v(667);class M{constructor(e,t){this.scene=e,this.material=t,this.name=`MToonOutline_${t.name}_${M.rendererId++}`,this.scene._addComponent(this),this._engine=this.scene.getEngine(),this._passIdForDrawWrapper=[];for(let e=0;e<1;++e)this._passIdForDrawWrapper[e]=this._engine.createRenderPassId(`Outline Renderer (${e})`)}register(){this.scene._afterRenderingMeshStage.registerStep(_.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)}rebuild(){}dispose(){for(let e=0;e<this._passIdForDrawWrapper.length;++e)this._engine.releaseRenderPassId(this._passIdForDrawWrapper[e])}render(e,t,i){i=null!=i?i:this._passIdForDrawWrapper[0];const n=this.scene,r=e.effect;if(!r||!r.isReady()||!this.scene.activeCamera)return;const a=e._getDrawWrapper(i,!0);if(!a)return;if(a.setEffect(r),!a.effect||!a.effect.isReady())return;const o=e.getMesh(),s=o._internalAbstractMeshDataInfo._actAsRegularMesh?o:null,l=e.getRenderingMesh(),h=s||l;n.activeCamera&&(this.material.applyOutlineCullMode(),this.material.enableOutlineRender(),this._engine.enableEffect(a),this.isHardwareInstancedRendering(e,t)||l._bind(e,r,this.material.fillMode),this.material._preBind(r),l._processRendering(h,e,r,this.material.fillMode,t,this.isHardwareInstancedRendering(e,t),((t,i,n)=>{n&&n.bindForSubMesh(i,h,e)}),this.material),this.material.restoreOutlineCullMode(),this.material.disaableOutlineRender())}_afterRenderingMesh(e,t,i){if(!this.willRender(t))return;const n=this._engine.cullBackFaces;this._engine.cullBackFaces=!1,this.render(t,i,this._passIdForDrawWrapper[0]),this._engine.cullBackFaces=n}isHardwareInstancedRendering(e,t){return!!this._engine.getCaps().instancedArrays&&null!==t.visibleInstances[e._id]&&void 0!==t.visibleInstances[e._id]&&e.getRenderingMesh().hasThinInstances}willRender(e){const t=e.getMaterial();return!(!t||"MToonMaterial"!==t.getClassName()||t.getOutlineRendererName()!==this.name)}}M.rendererId=0;var A=v(713);class I extends A.MaterialDefines{constructor(e){super(e),this.CUSTOMUSERLIGHTING=!0,this.MTOON_OUTLINE_WIDTH_WORLD=!1,this.MTOON_OUTLINE_WIDTH_SCREEN=!1,this.MTOON_OUTLINE_COLOR_FIXED=!1,this.MTOON_OUTLINE_COLOR_MIXED=!1,this.MTOON_DEBUG_NORMAL=!1,this.MTOON_DEBUG_LITSHADERRATE=!1,this.SHADE=!1,this.SHADEDIRECTUV=0,this.RECEIVE_SHADOW=!1,this.RECEIVE_SHADOWDIRECTUV=0,this.SHADING_GRADE=!1,this.SHADING_GRADEDIRECTUV=0,this.RIM=!1,this.RIMDIRECTUV=0,this.MATCAP=!1,this.MATCAPDIRECTUV=0,this.OUTLINE_WIDTH=!1,this.OUTLINE_WIDTHDIRECTUV=0,this.UV_ANIMATION_MASK=!1,this.UV_ANIMATION_MASKDIRECTUV=0,this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.DIFFUSE=!1,this.DIFFUSEDIRECTUV=0,this.BAKED_VERTEX_ANIMATION_TEXTURE=!1,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.BUMP=!1,this.BUMPDIRECTUV=0,this.PARALLAX=!1,this.PARALLAXOCCLUSION=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHAFROMDIFFUSE=!1,this.POINTSIZE=!1,this.FOG=!1,this.NORMAL=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.OBJECTSPACE_NORMALMAP=!1,this.LOGARITHMICDEPTH=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.NONUNIFORMSCALING=!1,this.PREMULTIPLYALPHA=!1,this.ALPHATEST_AFTERALLALPHACOMPUTATIONS=!1,this.ALPHABLEND=!0,this.PREPASS=!1,this.PREPASS_IRRADIANCE=!1,this.PREPASS_IRRADIANCE_INDEX=-1,this.PREPASS_ALBEDO_SQRT=!1,this.PREPASS_ALBEDO_SQRT_INDEX=-1,this.PREPASS_DEPTH=!1,this.PREPASS_DEPTH_INDEX=-1,this.PREPASS_NORMAL=!1,this.PREPASS_NORMAL_INDEX=-1,this.PREPASS_POSITION=!1,this.PREPASS_POSITION_INDEX=-1,this.PREPASS_VELOCITY=!1,this.PREPASS_VELOCITY_INDEX=-1,this.PREPASS_REFLECTIVITY=!1,this.PREPASS_REFLECTIVITY_INDEX=-1,this.SCENE_MRT_COUNT=0,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=!1,this.TONEMAPPING_ACES=!1,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.MULTIVIEW=!1,this.ORDER_INDEPENDENT_TRANSPARENCY=!1,this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!1,this.IS_REFLECTION_LINEAR=!1,this.IS_REFRACTION_LINEAR=!1,this.EXPOSURE=!1,this.FLIP_U=!1,this.FLIP_V=!1,this.rebuild()}setReflectionMode(e){throw new Error("This material cannot use `setReflectionMode`")}}const S={effect:null,subMesh:null};var E,x,N,b;!function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate"}(E||(E={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(x||(x={})),function(e){e[e.None=0]="None",e[e.WorldCorrdinates=1]="WorldCorrdinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}(N||(N={})),function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}(b||(b={}));class D extends h.PushMaterial{constructor(e,t){super(e,t),this._diffuseTexture=null,this.diffuseTexture=null,this._emissiveTexture=null,this.emissiveTexture=null,this._bumpTexture=null,this.bumpTexture=null,this._shadeTexture=null,this.shadeTexture=null,this._receiveShadowTexture=null,this.receiveShadowTexture=null,this._shadingGradeTexture=null,this.shadingGradeTexture=null,this._rimTexture=null,this.rimTexture=null,this._matCapTexture=null,this.matCapTexture=null,this._outlineWidthTexture=null,this.outlineWidthTexture=null,this._uvAnimationMaskTexture=null,this.uvAnimationMaskTexture=null,this.diffuseColor=new a.Color3(1,1,1),this.ambientColor=new a.Color3(0,0,0),this.emissiveColor=new a.Color3(0,0,0),this.shadeColor=new a.Color3(.97,.81,.86),this.rimColor=new a.Color3(0,0,0),this.outlineColor=new a.Color3(0,0,0),this.useEmissiveAsIllumination=!1,this.linkEmissiveWithDiffuse=!1,this.useReflectionOverAlpha=!1,this._disableLighting=!1,this.useObjectSpaceNormalMap=!1,this.useParallax=!1,this.useParallaxOcclusion=!1,this.specularSupported=!1,this.useLightmapAsShadowmap=!1,this.useVertexColor=!1,this.useBones=!0,this.useMorphTargets=!0,this.useVertexAlpha=!1,this.useBakedVertexAnimation=!1,this.alphaCutOff=.4,this._useAlphaFromDiffuseTexture=!0,this._maxSimultaneousLights=4,this._invertNormalMapX=!0,this._invertNormalMapY=!0,this._twoSidedLighting=!1,this._renderTargets=new i.SmartArray(16),this._worldViewProjectionMatrix=r.Matrix.Zero(),this._globalAmbientColor=new a.Color3(0,0,0),this._cacheHasRenderTargetTextures=!1,this._bumpScale=1,this._receiveShadowRate=1,this._shadingGradeRate=1,this._shadeShift=0,this._shadeToony=.9,this._lightColorAttenuation=0,this._indirectLightIntensity=.1,this._rimLightingMix=0,this._rimFresnelPower=1,this._rimLift=0,this._outlineWidth=.5,this._outlineScaledMaxDistance=1,this._outlineLightingMix=1,this._uvAnimationScrollX=0,this._uvAnimationScrollY=0,this._uvAnimationRotation=0,this._alphaTest=!1,this._alphaBlend=!1,this._debugMode=E.None,this.debugMode=E.None,this._outlineWidthMode=N.None,this.isOutline=0,this.outlineColorMode=x.MixedLighting,this._cullMode=b.Back,this._outlineCullMode=b.Front,this.outlineCullMode=b.Front,this.storedCullMode=b.Back,this.flipU=!1,this.flipV=!1,this.detailMap=new m.DetailMapConfiguration(this),this._attachImageProcessingConfiguration(null),this.getRenderTargetTextures=()=>(this._renderTargets.reset(),this._eventInfo.renderTargets=this._renderTargets,this._callbackPluginEventFillRenderTargetTextures(this._eventInfo),this._renderTargets),c.Effect.IncludesShadersStore.mtoonUboDeclaration||(c.Effect.IncludesShadersStore.mtoonUboDeclaration="// it will be replaced to UboDeclaration(WebGL2) or VertexDeclaration(WebGL1).\n\nlayout(std140, column_major) uniform;\n\nuniform Material\n{\n    // Color & Texture\n    vec4 vDiffuseColor;\n    vec2 vDiffuseInfos;\n    mat4 diffuseMatrix;\n    vec4 vEmissiveColor;\n    vec2 vEmissiveInfos;\n    mat4 emissiveMatrix;\n    vec3 vBumpInfos;\n    mat4 bumpMatrix;\n    vec3 vShadeColor;\n    vec2 vShadeInfos;\n    mat4 shadeMatrix;\n    vec2 vReceiveShadowInfos;\n    mat4 receiveShadowMatrix;\n    vec2 vShadingGradeInfos;\n    mat4 shadingGradeMatrix;\n    vec3 vRimColor;\n    vec2 vRimInfos;\n    mat4 rimMatrix;\n    vec2 vMatCapInfos;\n    mat4 matCapMatrix;\n    vec4 vOutlineColor;\n    vec2 vOutlineWidthInfos;\n    mat4 outlineWidthMatrix;\n    vec2 vUvAnimationMaskInfos;\n    mat4 uvAnimationMaskMatrix;\n\n    // babylon specific\n    vec2 vTangentSpaceParams;\n    float pointSize;\n\n    // MToon params\n    float shadingGradeRate;\n    float receiveShadowRate;\n    float shadeShift;\n    float shadeToony;\n    float lightColorAttenuation;\n    float indirectLightIntensity;\n    float rimLightingMix;\n    float rimFresnelPower;\n    float rimLift;\n    float outlineWidth;\n    float outlineScaledMaxDistance;\n    float outlineLightingMix;\n    float uvAnimationScrollX;\n    float uvAnimationScrollY;\n    float uvAnimationRotation;\n\n    vec3 vEyeUp;\n    float alphaCutOff;\n    vec3 vAmbientColor;\n    float aspect;\n    float isOutline;\n    vec4 time;\n};\n\n// babylon specific\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n",c.Effect.IncludesShadersStore.mtoonVertexDeclaration="// Uniforms\nuniform mat4 viewProjection;\nuniform mat4 view;\nuniform mat4 projection;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float isOutline;\nuniform float aspect;\n\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\nuniform mat4 shadeMatrix;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\nuniform mat4 receiveShadowMatrix;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\nuniform mat4 shadingGradeMatrix;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\nuniform mat4 rimMatrix;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\nuniform mat4 matCapMatrix;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\nuniform mat4 outlineWidthMatrix;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\nuniform mat4 uvAnimationMaskMatrix;\n#endif\n\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n",c.Effect.IncludesShadersStore.mtoonFragmentDeclaration="uniform vec4 vEyePosition;\n\n// Colors\nuniform vec4 vDiffuseColor;\nuniform vec3 vEmissiveColor;\nuniform vec3 vShadeColor;\nuniform vec3 vRimColor;\nuniform vec4 vOutlineColor;\nuniform vec3 vAmbientColor;\n\nuniform vec3 vEyeUp;\nuniform float aspect;\nuniform float alphaCutOff;\nuniform float visibility;\nuniform float isOutline;\nuniform vec4 time;\n\n// Samplers\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\n#endif\n\n// MToon params\nuniform float shadingGradeRate;\nuniform float receiveShadowRate;\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float uvAnimationScrollX;\nuniform float uvAnimationScrollY;\nuniform float uvAnimationRotation;\n",c.Effect.IncludesShadersStore.mtoonFragmentFunctions="\n/**\n* Compute Directional or Point light direction\n*/\nvec3 computeLightDirection(vec4 lightData) {\n    return normalize(mix(lightData.xyz - vPositionW, -lightData.xyz, lightData.w));\n}\n\n/**\n* Compute Spot Light direction\n*/\nvec3 computeSpotLightDirection(vec4 lightData) {\n    return normalize(lightData.xyz - vPositionW);\n}\n\n/**\n* Compute Hemispheric light direction\n*/\nvec3 computeHemisphericLightDirection(vec4 lightData, vec3 vNormal) {\n    return normalize(lightData.xyz);\n}\n\n/**\n* Compute MToon diffuse lighting\n*/\nvec4 computeMToonDiffuseLighting(vec3 worldView, vec3 worldNormal, vec2 mainUv, vec3 lightDirection, vec4 lightDiffuse, float shadowAttenuation) {\n    float _receiveShadow = receiveShadowRate;\n#ifdef RECEIVE_SHADOW\n    _receiveShadow = _receiveShadow * texture2D(receiveShadowSampler, mainUv).r * vReceiveShadowInfos.y;\n#endif\n\n    float _shadingGrade = 0.0;\n#ifdef SHADING_GRADE\n    _shadingGrade = 1.0 - texture2D(shadingGradeSampler, mainUv).r * vShadingGradeInfos.y;\n#endif\n    _shadingGrade = 1.0 - shadingGradeRate * _shadingGrade;\n\n    // Lighting\n    vec3 _lightColor = lightDiffuse.rgb * step(0.5, length(lightDirection)); // length(lightDir) is zero if directional light is disabled.\n    float _dotNL = dot(lightDirection, worldNormal);\n#ifdef MTOON_FORWARD_ADD\n    float _lightAttenuation = 1.0;\n#else\n    float _lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, _receiveShadow);\n#endif\n\n    // lighting intensity\n    float _lightIntensity = _dotNL;\n    _lightIntensity = _lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]\n    _lightIntensity = _lightIntensity * _lightAttenuation; // receive shadow\n    _lightIntensity = _lightIntensity * _shadingGrade; // darker\n    _lightIntensity = _lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\n    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]\n    float _maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);\n    float _minIntensityThreshold = shadeShift;\n    _lightIntensity = clamp((_lightIntensity - _minIntensityThreshold) / max(EPS_COL, (_maxIntensityThreshold - _minIntensityThreshold)), 0.0, 1.0);\n\n    // Albedo color\n    vec3 _shade = vShadeColor;\n#ifdef SHADE\n    _shade = _shade * texture2D(shadeSampler, mainUv).rgb * vShadeInfos.y;\n#endif\n\n    vec4 _lit = vDiffuseColor;\n#ifdef DIFFUSE\n    _lit = _lit * texture2D(diffuseSampler, mainUv) * vDiffuseInfos.y;\n#endif\n    vec3 _col = mix(_shade.rgb, _lit.rgb, _lightIntensity);\n\n    // Direct Light\n    vec3 _lighting = _lightColor;\n    _lighting = mix(_lighting, vec3(max(EPS_COL, max(_lighting.x, max(_lighting.y, _lighting.z)))), lightColorAttenuation); // color atten\n#ifdef MTOON_FORWARD_ADD\n    _lighting *= 0.5; // darken if additional light\n    _lighting *= min(0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert\n    _lighting *= shadowAttenuation; // darken if receiving shadow\n#else\n    // base light does not darken.\n#endif\n    _col *= _lighting;\n\n    // Indirect Light\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _toonedGI = vAmbientColor.rgb; // TODO: GI\n    vec3 _indirectLighting = mix(_toonedGI, vAmbientColor.rgb, indirectLightIntensity);\n    _indirectLighting = mix(_indirectLighting, vec3(max(EPS_COL, max(_indirectLighting.x, max(_indirectLighting.y, _indirectLighting.z)))), lightColorAttenuation); // color atten\n    _col += _indirectLighting * _lit.rgb;\n\n    _col = min(_col.rgb, _lit.rgb); // comment out if you want to PBR absolutely.\n#endif\n\n    // parametric rim lighting\n#ifdef MTOON_FORWARD_ADD\n    vec3 _staticRimLighting = vec3(0.0);\n    vec3 _mixedRimLighting = _lighting;\n#else\n    vec3 _staticRimLighting = vec3(1.0);\n    vec3 _mixedRimLighting = _lighting + _indirectLighting;\n#endif\n    vec3 _rimLighting = mix(_staticRimLighting, _mixedRimLighting, rimLightingMix);\n    vec3 _rimColor = vRimColor.rgb;\n#ifdef RIM\n    _rimColor = _rimColor * texture2D(rimSampler, vRimUV + mainUv).rgb * vRimInfos.y;\n#endif\n    vec3 _rim = pow(clamp(1.0 - dot(worldNormal, worldView) + rimLift, 0.0, 1.0), rimFresnelPower) * _rimColor.rgb;\n    _col += mix(_rim * _rimLighting, vec3(0.0), isOutline);\n\n    // additive matcap\n#ifdef MTOON_FORWARD_ADD\n#else\n#ifdef MATCAP\n    vec3 _worldViewUp = normalize(vEyeUp - worldView * dot(worldView, vEyeUp));\n    vec3 _worldViewRight = normalize(cross(worldView, _worldViewUp));\n    vec2 _matCapUv = vec2(dot(_worldViewRight, worldNormal), dot(_worldViewUp, worldNormal)) * 0.5 + 0.5;\n    // uv.y is reversed\n    _matCapUv.y = (1.0 - _matCapUv.y);\n    vec3 _matCapLighting = texture2D(matCapSampler, _matCapUv).rgb * vMatCapInfos.y;\n    _col += mix(_matCapLighting, vec3(0.0), isOutline);\n#endif\n#endif\n\n    // Emission\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _emission = vEmissiveColor.rgb;\n#ifdef EMISSIVE\n    _emission *= texture2D(emissiveSampler, mainUv).rgb * vEmissiveInfos.y;\n#endif\n    _col += mix(_emission, vec3(0.0), isOutline);\n#endif\n\n    float _alpha = 1.0;\n\n#if defined(ALPHABLEND) || defined(ALPHATEST)\n    _alpha = mix(_lit.a, _lit.a * vOutlineColor.a, isOutline);\n#endif\n\n    // outline\n#ifdef MTOON_OUTLINE_COLOR_FIXED\n    _col = mix(_col, vOutlineColor.rgb, isOutline);\n#elif defined(MTOON_OUTLINE_COLOR_MIXED)\n    _col = mix(_col, vOutlineColor.rgb * mix(vec3(1.0), _col, outlineLightingMix), isOutline);\n#else\n#endif\n\n    // debug\n#ifdef MTOON_DEBUG_NORMAL\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(worldNormal * 0.5 + 0.5, _lit.a);\n    #endif\n#elif defined(MTOON_DEBUG_LITSHADERATE)\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(_lightIntensity, _lit.a);\n    #endif\n#endif\n\n    return vec4(_col, _alpha);\n}\n",c.Effect.IncludesShadersStore.mtoonLightFragment="#ifdef LIGHT{X}\n    #if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n        //No light calculation\n    #else\n        #ifdef PBR\n            // Compute Pre Lighting infos\n            #ifdef SPOTLIGHT{X}\n                preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(POINTLIGHT{X})\n                preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(HEMILIGHT{X})\n                preInfo = computeHemisphericPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(DIRLIGHT{X})\n                preInfo = computeDirectionalPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #endif\n\n            preInfo.NdotV = NdotV;\n\n            // Compute Attenuation infos\n            #ifdef SPOTLIGHT{X}\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w);\n                #else\n                    preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n                    preInfo.attenuation *= computeDirectionalLightFalloff(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n                #endif\n            #elif defined(POINTLIGHT{X})\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n                #else\n                    preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n                #endif\n            #else\n                preInfo.attenuation = 1.0;\n            #endif\n\n            // Simulates Light radius for diffuse and spec term\n            // clear coat is using a dedicated roughness\n            #ifdef HEMILIGHT{X}\n                preInfo.roughness = roughness;\n            #else\n                preInfo.roughness = adjustRoughnessFromLightProperties(roughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n            #endif\n\n            // Diffuse contribution\n            #ifdef HEMILIGHT{X}\n                info.diffuse = computeHemisphericDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb, light{X}.vLightGround);\n            #elif defined(SS_TRANSLUCENCY)\n                info.diffuse = computeDiffuseAndTransmittedLighting(preInfo, light{X}.vLightDiffuse.rgb, subSurfaceOut.transmittance);\n            #else\n                info.diffuse = computeDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb);\n            #endif\n\n            // Specular contribution\n            #ifdef SPECULARTERM\n                #ifdef ANISOTROPIC\n                    info.specular = computeAnisotropicSpecularLighting(preInfo, viewDirectionW, normalW, anisotropicOut.anisotropicTangent, anisotropicOut.anisotropicBitangent, anisotropicOut.anisotropy, clearcoatOut.specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n                #else\n                    info.specular = computeSpecularLighting(preInfo, normalW, clearcoatOut.specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n                #endif\n            #endif\n\n            // Sheen contribution\n            #ifdef SHEEN\n                #ifdef SHEEN_LINKWITHALBEDO\n                    // BE Carefull: Sheen intensity is replacing the roughness value.\n                    preInfo.roughness = sheenOut.sheenIntensity;\n                #else\n                    #ifdef HEMILIGHT{X}\n                        preInfo.roughness = sheenOut.sheenRoughness;\n                    #else\n                        preInfo.roughness = adjustRoughnessFromLightProperties(sheenOut.sheenRoughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n                    #endif\n                #endif\n                info.sheen = computeSheenLighting(preInfo, normalW, sheenOut.sheenColor, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n            #endif\n\n            // Clear Coat contribution\n            #ifdef CLEARCOAT\n                // Simulates Light radius\n                #ifdef HEMILIGHT{X}\n                    preInfo.roughness = clearcoatOut.clearCoatRoughness;\n                #else\n                    preInfo.roughness = adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n                #endif\n\n                info.clearCoat = computeClearCoatLighting(preInfo, clearcoatOut.clearCoatNormalW, clearcoatOut.clearCoatAARoughnessFactors.x, clearcoatOut.clearCoatIntensity, light{X}.vLightDiffuse.rgb);\n\n                #ifdef CLEARCOAT_TINT\n                    // Absorption\n                    absorption = computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract, preInfo.L, clearcoatOut.clearCoatNormalW, clearcoatOut.clearCoatColor, clearcoatOut.clearCoatThickness, clearcoatOut.clearCoatIntensity);\n                    info.diffuse *= absorption;\n                    #ifdef SPECULARTERM\n                        info.specular *= absorption;\n                    #endif\n                #endif\n\n                // Apply energy conservation on diffuse and specular term.\n                info.diffuse *= info.clearCoat.w;\n                #ifdef SPECULARTERM\n                    info.specular *= info.clearCoat.w;\n                #endif\n                #ifdef SHEEN\n                    info.sheen *= info.clearCoat.w;\n                #endif\n            #endif\n        #else\n            #ifdef SPOTLIGHT{X}\n                info = computeSpotLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDirection, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightDiffuse.a, glossiness);\n            #elif defined(HEMILIGHT{X})\n                info = computeHemisphericLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightGround, glossiness);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                info = computeLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightDiffuse.a, glossiness);\n            #endif\n        #endif\n\n        #ifdef PROJECTEDLIGHTTEXTURE{X}\n            info.diffuse *= computeProjectionTextureDiffuseLighting(projectionLightSampler{X}, textureProjectionMatrix{X});\n        #endif\n    #endif\n\n    #ifdef SHADOW{X}\n        #ifdef SHADOWCSM{X}\n            for (int i = 0; i < SHADOWCSMNUM_CASCADES{X}; i++)\n            {\n                #ifdef SHADOWCSM_RIGHTHANDED{X}\n                    diff{X} = viewFrustumZ{X}[i] + vPositionFromCamera{X}.z;\n                #else\n                    diff{X} = viewFrustumZ{X}[i] - vPositionFromCamera{X}.z;\n                #endif\n                if (diff{X} >= 0.) {\n                    index{X} = i;\n                    break;\n                }\n            }\n\n            #ifdef SHADOWCSMUSESHADOWMAXZ{X}\n            if (index{X} >= 0)\n            #endif\n            {\n                #if defined(SHADOWPCF{X})\n                    #if defined(SHADOWLOWQUALITY{X})\n                        shadow = computeShadowWithCSMPCF1(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #elif defined(SHADOWMEDIUMQUALITY{X})\n                        shadow = computeShadowWithCSMPCF3(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #else\n                        shadow = computeShadowWithCSMPCF5(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #endif\n                #elif defined(SHADOWPCSS{X})\n                    #if defined(SHADOWLOWQUALITY{X})\n                        shadow = computeShadowWithCSMPCSS16(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #elif defined(SHADOWMEDIUMQUALITY{X})\n                        shadow = computeShadowWithCSMPCSS32(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #else\n                        shadow = computeShadowWithCSMPCSS64(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #endif\n                #else\n                    shadow = computeShadowCSM(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                #endif\n\n                #ifdef SHADOWCSMDEBUG{X}\n                    shadowDebug{X} = vec3(shadow) * vCascadeColorsMultiplier{X}[index{X}];\n                #endif\n\n                #ifndef SHADOWCSMNOBLEND{X}\n                    float frustumLength = frustumLengths{X}[index{X}];\n                    float diffRatio = clamp(diff{X} / frustumLength, 0., 1.) * cascadeBlendFactor{X};\n                    if (index{X} < (SHADOWCSMNUM_CASCADES{X} - 1) && diffRatio < 1.)\n                    {\n                        index{X} += 1;\n                        float nextShadow = 0.;\n                        #if defined(SHADOWPCF{X})\n                            #if defined(SHADOWLOWQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCF1(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #elif defined(SHADOWMEDIUMQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCF3(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #else\n                                nextShadow = computeShadowWithCSMPCF5(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #endif\n                        #elif defined(SHADOWPCSS{X})\n                            #if defined(SHADOWLOWQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCSS16(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #elif defined(SHADOWMEDIUMQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCSS32(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #else\n                                nextShadow = computeShadowWithCSMPCSS64(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #endif\n                        #else\n                            nextShadow = computeShadowCSM(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                        #endif\n\n                        shadow = mix(nextShadow, shadow, diffRatio);\n                        #ifdef SHADOWCSMDEBUG{X}\n                            shadowDebug{X} = mix(vec3(nextShadow) * vCascadeColorsMultiplier{X}[index{X}], shadowDebug{X}, diffRatio);\n                        #endif\n                    }\n                #endif\n            }\n        #elif defined(SHADOWCLOSEESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPOISSON{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCF{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCSS{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #else\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #endif\n\n        #ifdef SHADOWONLY\n            #ifndef SHADOWINUSE\n                #define SHADOWINUSE\n            #endif\n            globalShadow += shadow;\n            shadowLightCount += 1.0;\n        #endif\n    #else\n        shadow = 1.;\n    #endif\n\n    #ifndef SHADOWONLY\n        #ifdef CUSTOMUSERLIGHTING\n            // Compute and reflect MToon lighting\n            #ifdef SPOTLIGHT{X}\n                lightDirection = computeSpotLightDirection(light{X}.vLightData);\n            #elif defined(HEMILIGHT{X})\n                lightDirection = computeHemisphericLightDirection(light{X}.vLightData, normalW.xyz);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                lightDirection = computeLightDirection(light{X}.vLightData);\n            #endif\n            mtoonDiffuse = computeMToonDiffuseLighting(viewDirectionW.xyz, normalW.xyz, mainUv, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\n            diffuseBase += mtoonDiffuse.rgb;\n            alpha = min(alpha, mtoonDiffuse.a);\n            #if defined(ALPHATEST) && ALPHATEST\n                alpha = (alpha - alphaCutOff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage\n                if (alpha < alphaCutOff) {\n                    discard;\n                }\n                alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity\n            #else\n                if (alpha - 0.0001 < 0.000) { // Slightly improves rendering with layered transparency\n                    discard;\n                }\n            #endif\n        #elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\n            diffuseBase += lightmapColor.rgb * shadow;\n            #ifdef SPECULARTERM\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    specularBase += info.specular * shadow * lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef CLEARCOAT\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    clearCoatBase += info.clearCoat.rgb * shadow * lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef SHEEN\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    sheenBase += info.sheen.rgb * shadow;\n                #endif\n            #endif\n        #else\n            #ifdef SHADOWCSMDEBUG{X}\n                diffuseBase += info.diffuse * shadowDebug{X};\n            #else\n                diffuseBase += info.diffuse * shadow;\n            #endif\n            #ifdef SPECULARTERM\n                specularBase += info.specular * shadow;\n            #endif\n            #ifdef CLEARCOAT\n                clearCoatBase += info.clearCoat.rgb * shadow;\n            #endif\n            #ifdef SHEEN\n                sheenBase += info.sheen.rgb * shadow;\n            #endif\n        #endif\n    #endif\n#endif\n",c.Effect.IncludesShadersStore.mtoonBumpFragment="// replace vBumpUV to mainUv\nvec2 uvOffset = vec2(0.0, 0.0);\n\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n    #ifdef NORMALXYSCALE\n        float normalScale = 1.0;\n    #elif defined(BUMP)\n        float normalScale = vBumpInfos.y;\n    #else\n        float normalScale = 1.0;\n    #endif\n\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #elif defined(BUMP)\n        // vec2 TBNUV = gl_FrontFacing ? vBumpUV : -vBumpUV;\n        vec2 TBNUV = gl_FrontFacing ? mainUv : -mainUv;\n        mat3 TBN = cotangent_frame(normalW * normalScale, vPositionW, TBNUV, vTangentSpaceParams);\n    #else\n        vec2 TBNUV = gl_FrontFacing ? vDetailUV : -vDetailUV;\n        mat3 TBN = cotangent_frame(normalW * normalScale, vPositionW, TBNUV, vec2(1., 1.));\n    #endif\n#elif defined(ANISOTROPIC)\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #else\n        // flip the uv for the backface\n        vec2 TBNUV = gl_FrontFacing ? vMainUV1 : -vMainUV1;\n        mat3 TBN = cotangent_frame(normalW, vPositionW, TBNUV, vec2(1., 1.));\n    #endif\n#endif\n\n#ifdef PARALLAX\n    mat3 invTBN = transposeMat3(TBN);\n\n    #ifdef PARALLAXOCCLUSION\n        // uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, vBumpUV, vBumpInfos.z);\n        uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, mainUv, vBumpInfos.z);\n    #else\n        uvOffset = parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z);\n    #endif\n#endif\n\n#ifdef DETAIL\n    vec4 detailColor = texture2D(detailSampler, vDetailUV + uvOffset);\n    vec2 detailNormalRG = detailColor.wy * 2.0 - 1.0;\n    float detailNormalB = sqrt(1. - saturate(dot(detailNormalRG, detailNormalRG)));\n    vec3 detailNormal = vec3(detailNormalRG, detailNormalB);\n#endif\n\n#ifdef BUMP\n    #ifdef OBJECTSPACE_NORMALMAP\n        // normalW = normalize(texture2D(bumpSampler, vBumpUV).xyz  * 2.0 - 1.0);\n        normalW = normalize(texture2D(bumpSampler, mainUv).xyz  * 2.0 - 1.0);\n        normalW = normalize(mat3(normalMatrix) * normalW);\n    #elif !defined(DETAIL)\n        // normalW = perturbNormal(TBN, texture2D(bumpSampler, vBumpUV + uvOffset).xyz, vBumpInfos.y);\n        normalW = perturbNormal(TBN, texture2D(bumpSampler, mainUv + uvOffset).xyz, vBumpInfos.y);\n    #else\n        // vec3 bumpNormal = texture2D(bumpSampler, vBumpUV + uvOffset).xyz * 2.0 - 1.0;\n        vec3 bumpNormal = texture2D(bumpSampler, mainUv + uvOffset).xyz * 2.0 - 1.0;\n        // Reference for normal blending: https://blog.selfshadow.com/publications/blending-in-detail/\n        #if DETAIL_NORMALBLENDMETHOD == 0 // whiteout\n            detailNormal.xy *= vDetailInfos.z;\n            vec3 blendedNormal = normalize(vec3(bumpNormal.xy + detailNormal.xy, bumpNormal.z * detailNormal.z));\n        #elif DETAIL_NORMALBLENDMETHOD == 1 // RNM\n            detailNormal.xy *= vDetailInfos.z;\n            bumpNormal += vec3(0.0, 0.0, 1.0);\n            detailNormal *= vec3(-1.0, -1.0, 1.0);\n            vec3 blendedNormal = bumpNormal * dot(bumpNormal, detailNormal) / bumpNormal.z - detailNormal;\n        #endif\n        normalW = perturbNormalBase(TBN, blendedNormal, vBumpInfos.y);\n    #endif\n#elif defined(DETAIL)\n        detailNormal.xy *= vDetailInfos.z;\n        normalW = perturbNormalBase(TBN, detailNormal, vDetailInfos.z);\n#endif\n",c.Effect.ShadersStore.mtoonVertexShader="// it is based on default.vertex.fx\n// This include is special, it will be replaced to UboDeclaration(WebGL2) or VertexDeclaration(WebGL1).\n// @see effect.ts\n#include<__decl__mtoonVertex>\n\n// Attributes\n\n#define CUSTOM_VERTEX_BEGIN\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n\n#include<helperFunctions>\n\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n\n// Uniforms\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n\n#include<mainUVVaryingDeclaration>[1..7]\n\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n// # if defined(SPECULARTERM)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n// # endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth)\n#include<samplerVertexDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask)\n\n// Additional Uniforms\n#ifdef OUTLINE_WIDTH\n    uniform sampler2D outlineWidthSampler;\n#endif\n\n// Output\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n\n#include<bumpVertexDeclaration>\n\n#include<clipPlaneVertexDeclaration>\n\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n// # ifdef REFLECTIONMAP_SKYBOX\n// varying vec3 vPositionUVW;\n// # endif\n\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n// varying vec3 vDirectionW;\n// # endif\n\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n\nvoid main(void) {\n\n    #define CUSTOM_VERTEX_MAIN_BEGIN\n\n    vec3 positionUpdated = position;\n#ifdef NORMAL\n    vec3 normalUpdated = normal;\n#endif\n#ifdef TANGENT\n    vec4 tangentUpdated = tangent;\n#endif\n#ifdef UV1\n    vec2 uvUpdated = uv;\n#endif\n\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n\n// # ifdef REFLECTIONMAP_SKYBOX\n//     vPositionUVW = positionUpdated;\n// # endif\n\n#define CUSTOM_VERTEX_UPDATE_POSITION\n\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n\n#include<instancesVertex>\n\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n    // Compute velocity before bones computation\n    vCurrentPosition = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\n    vPreviousPosition = previousViewProjection * finalPreviousWorld * vec4(positionUpdated, 1.0);\n#endif\n\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n\n    // Texture coordinates\n#ifndef UV1\n    vec2 uvUpdated = vec2(0., 0.);\n#endif\n#ifdef MAINUV1\n    vMainUV1 = uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n\n    float outlineTex = 1.0;\n    if (isOutline == 1.0) {\n#ifdef OUTLINE_WIDTH\n    #if OUTLINE_WIDTHDIRECTUV == 0\n        if (vOutlineWidthInfos.x == 0.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uvUpdated, 1.0, 0.0));\n        }\n        #ifdef UV2\n        else if (vOutlineWidthInfos.x == 1.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv2, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV3\n        else if (vOutlineWidthInfos.x == 2.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv3, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV4\n        else if (vOutlineWidthInfos.x == 3.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv4, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV5\n        else if (vOutlineWidthInfos.x == 4.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv5, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV6\n        else if (vOutlineWidthInfos.x == 5.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv6, 1.0, 0.0));\n        }\n        #endif\n    #elif defined(MAINUV1)\n        vec2 vOutlineWidthUV = vMainUV1;\n    #elif defined(MAINUV2)\n        vec2 vOutlineWidthUV = vMainUV2;\n    #else\n        vec2 vOutlineWidthUV = vec2(0., 0.);\n    #endif\n        outlineTex = texture2D(outlineWidthSampler, vOutlineWidthUV).r * vOutlineWidthInfos.y;\n#endif\n\n#if defined(MTOON_OUTLINE_WIDTH_WORLD) && defined(NORMAL)\n        // move slightly world normal\n        vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * length(transposeMat3(inverseMat3(mat3(finalWorld))) * normalUpdated) * normalUpdated;\n        positionUpdated += outlineOffset;\n#endif\n    } // End isOutline == 1.0\n\n    vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n#ifdef NORMAL\n    mat3 normalWorld = mat3(finalWorld);\n\n    #if defined(INSTANCES) && defined(THIN_INSTANCES)\n        vNormalW = normalUpdated / vec3(dot(normalWorld[0], normalWorld[0]), dot(normalWorld[1], normalWorld[1]), dot(normalWorld[2], normalWorld[2]));\n        vNormalW = normalize(normalWorld * vNormalW);\n    #else\n        #ifdef NONUNIFORMSCALING\n            normalWorld = transposeMat3(inverseMat3(normalWorld));\n        #endif\n\n        vNormalW = normalize(normalWorld * normalUpdated);\n    #endif\n#endif\n\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n\n#ifdef MULTIVIEW\n    if (gl_ViewID_OVR == 0u) {\n        gl_Position = viewProjection * worldPos;\n    } else {\n        gl_Position = viewProjectionR * worldPos;\n    }\n#else\n    gl_Position = viewProjection * worldPos;\n#endif\n\n    if (isOutline == 1.0) {\n#if defined(MTOON_OUTLINE_WIDTH_SCREEN) && defined(NORMAL)\n        vec3 viewNormal = transposeMat3(inverseMat3(mat3(view) * mat3(finalWorld))) * normalUpdated;\n        vec3 clipNormal = mat3(projection) * viewNormal;\n        vec2 projectedNormal = normalize(clipNormal.xy);\n        projectedNormal *= min(gl_Position.w, outlineScaledMaxDistance);\n        projectedNormal.x /= aspect; // aspect in original mtoon is y/x. aspect in babylon is x/y.\n        gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(normalize(viewNormal).z), 0.0, 1.0); // ignore offset when normal toward camera\n#endif\n\n        gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic from three-vrm\n    }\n\n    worldPos = finalWorld * vec4(positionUpdated, 1.0);\n    vPositionW = vec3(worldPos);\n\n#include<prePassVertex>\n\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n//     vDirectionW = normalize(vec3(finalWorld * vec4(positionUpdated, 0.0)));\n// # endif\n\n    #include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n    // # if defined(SPECULARTERM)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n    // # endif\n    #include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_MATRIXNAME_,shade,_INFONAME_,ShadeInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_MATRIXNAME_,receiveShadow,_INFONAME_,ReceiveShadowInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_MATRIXNAME_,shadingGrade,_INFONAME_,ShadingGradeInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_MATRIXNAME_,rim,_INFONAME_,RimInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_MATRIXNAME_,matCap,_INFONAME_,MatCapInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_MATRIXNAME_,uvAnimationMask,_INFONAME_,uvAnimationMaskInfos.x)\n\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\n    vColor = color;\n#elif defined(INSTANCESCOLOR) && INSTANCESCOLOR\n    vColor = instanceColor;\n#endif\n\n#include<pointCloudVertex>\n#include<logDepthVertex>\n\n#define CUSTOM_VERTEX_MAIN_END\n\n}\n",c.Effect.ShadersStore.mtoonFragmentShader="#include<__decl__mtoonFragment>\n\n#extension GL_OES_standard_derivatives : enable\n\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n\n#define CUSTOM_FRAGMENT_BEGIN\n\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n// Constants\n#define RECIPROCAL_PI2 0.15915494\n#define PI_2 6.28318530718\n#define EPS_COL 0.00001\n\n// Input\nvarying vec3 vPositionW;\n\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n\n#include<mainUVVaryingDeclaration>[1..7]\n\n// Helper functions\n#include<helperFunctions>\n\n// Lights\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n// Samplers\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_SAMPLERNAME_,shade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_SAMPLERNAME_,receiveShadow)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_SAMPLERNAME_,shadingGrade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_SAMPLERNAME_,rim)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_SAMPLERNAME_,matCap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth,_SAMPLERNAME_,outlineWidth)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_SAMPLERNAME_,uvAnimationMask)\n\n#include<mtoonFragmentFunctions>\n\n// # ifdef REFRACTION\n\n// # ifdef REFRACTIONMAP_3D\n// uniform samplerCube refractionCubeSampler;\n// # else\n// uniform sampler2D refraction2DSampler;\n// # endif\n\n// # endif\n\n// # if defined(SPECULARTERM)\n//     # include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n// # endif\n\n// // Fresnel\n// # include<fresnelFunction>\n\n// // Reflection\n// # ifdef REFLECTION\n// # ifdef REFLECTIONMAP_3D\n// uniform samplerCube reflectionCubeSampler;\n// # else\n// uniform sampler2D reflection2DSampler;\n// # endif\n\n// # ifdef REFLECTIONMAP_SKYBOX\n// varying vec3 vPositionUVW;\n// # else\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n// varying vec3 vDirectionW;\n// # endif\n\n// # endif\n\n// # include<reflectionFunction>\n\n// # endif\n\n#include<imageProcessingDeclaration>\n\n#include<imageProcessingFunctions>\n\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n\n#define CUSTOM_FRAGMENT_DEFINITIONS\n\nvoid main(void) {\n#ifdef MTOON_CLIP_IF_OUTLINE_IS_NONE\n    #ifdef MTOON_OUTLINE_WIDTH_WORLD\n    #elif defined(MTOON_OUTLINE_WIDTH_SCREEN)\n    #else\n        discard;\n    #endif\n#endif\n\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n\n#include<oitFragment>\n\n#include<clipPlaneFragment>\n\n    vec3 viewDirectionW = normalize(vEyePosition.xyz - vPositionW);\n\n    // Base color\n    vec4 baseColor = vec4(1., 1., 1., 1.);\n    vec3 diffuseColor = vec3(1., 1., 1.);\n\n    // Alpha\n    float alpha = 1.0;\n\n    // Bump\n#ifdef NORMAL\n    vec3 normalW = normalize(vNormalW);\n#else\n    vec3 normalW = normalize(-cross(dFdx(vPositionW), dFdy(vPositionW)));\n#endif\n\n#include<depthPrePass>\n\n    // Ambient color\n    vec3 baseAmbientColor = vec3(1., 1., 1.);\n    float glossiness = 0.;\n\n    // Lighting\n    vec3 diffuseBase = vec3(0., 0., 0.);\n    lightingInfo info;\n    float shadow = 1.;\n    vec3 lightDirection = vec3(0.0, 1.0, 0.0);\n    vec4 mtoonDiffuse = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // MToon UV\n    // All textures will use diffuse(_MainTex) UV\n    vec2 mainUv = vec2(0.0);\n#ifdef DIFFUSE\n    mainUv += vDiffuseUV;\n#elif defined(MAINUV1)\n    mainUv += vMainUV1;\n#elif defined(MAINUV2)\n    mainUv += vMainUV2;\n#endif\n\n    // uv anim\n    float uvAnim = time.y;\n#ifdef UV_ANIMATION_MASK\n    uvAnim *= texture2D(uvAnimationMaskSampler, mainUv).r;\n#endif\n    // translate uv in bottom-left origin coordinates.\n    // uv is reversed\n    mainUv += vec2(-uvAnimationScrollX, -uvAnimationScrollY) * uvAnim;\n    // rotate uv counter-clockwise around (0.5, 0.5) in bottom-left origin coordinates.\n    float rotateRad = uvAnimationRotation * PI_2 * uvAnim;\n    vec2 rotatePivot = vec2(0.5, 0.5);\n    mainUv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (mainUv - rotatePivot) + rotatePivot;\n\n#ifdef FLIP_U\n    mainUv.x = 1.0 - mainUv.x;\n#endif\n#ifdef FLIP_V\n    mainUv.y = 1.0 - mainUv.y;\n#endif\n\n#include<mtoonBumpFragment>\n\n#ifdef TWOSIDEDLIGHTING\n    normalW = gl_FrontFacing ? normalW : -normalW;\n#endif\n\n// include customized lightFragment\n#include<mtoonLightFragment>[0..maxSimultaneousLights]\n\n    vec3 finalDiffuse = clamp(diffuseBase, 0.0, 1.0) * baseColor.rgb;\n\n    // Composition\n    vec4 color = vec4(finalDiffuse, clamp(alpha, 0.0, 1.0));\n\n    color.rgb = max(color.rgb, 0.);\n#include<logDepthFragment>\n#include<fogFragment>\n\n// Apply image processing if relevant. As this applies in linear space,\n// We first move from gamma to linear.\n#ifdef IMAGEPROCESSINGPOSTPROCESS\n    color.rgb = toLinearSpace(color.rgb);\n#else\n    #ifdef IMAGEPROCESSING\n        // FIXME: support image processing\n        // color.rgb = toLinearSpace(color.rgb);\n        // color = applyImageProcessing(color);\n    #endif\n#endif\n\n    color.a *= visibility;\n\n#ifdef PREMULTIPLYALPHA\n    // Convert to associative (premultiplied) format if needed.\n    color.rgb *= color.a;\n#endif\n\n#ifdef PREPASS\n    float writeGeometryInfo = color.a > 0.4 ? 1.0 : 0.0;\n\n    gl_FragData[0] = color; // We can't split irradiance on std material\n\n    #ifdef PREPASS_POSITION\n    gl_FragData[PREPASS_POSITION_INDEX] = vec4(vPositionW, writeGeometryInfo);\n    #endif\n\n    #ifdef PREPASS_VELOCITY\n    vec2 a = (vCurrentPosition.xy / vCurrentPosition.w) * 0.5 + 0.5;\n    vec2 b = (vPreviousPosition.xy / vPreviousPosition.w) * 0.5 + 0.5;\n\n    vec2 velocity = abs(a - b);\n    velocity = vec2(pow(velocity.x, 1.0 / 3.0), pow(velocity.y, 1.0 / 3.0)) * sign(a - b) * 0.5 + 0.5;\n\n    gl_FragData[PREPASS_VELOCITY_INDEX] = vec4(velocity, 0.0, writeGeometryInfo);\n    #endif\n\n    #ifdef PREPASS_IRRADIANCE\n        gl_FragData[PREPASS_IRRADIANCE_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo); //  We can't split irradiance on std material\n    #endif\n\n    #ifdef PREPASS_DEPTH\n        gl_FragData[PREPASS_DEPTH_INDEX] = vec4(vViewPos.z, 0.0, 0.0, writeGeometryInfo); // Linear depth\n    #endif\n\n    #ifdef PREPASS_NORMAL\n        gl_FragData[PREPASS_NORMAL_INDEX] = vec4((view * vec4(normalW, 0.0)).rgb, writeGeometryInfo); // Normal\n    #endif\n\n    #ifdef PREPASS_ALBEDO_SQRT\n        gl_FragData[PREPASS_ALBEDO_SQRT_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo); // We can't split albedo on std material\n    #endif\n    #ifdef PREPASS_REFLECTIVITY\n        #if defined(SPECULAR)\n            gl_FragData[PREPASS_REFLECTIVITY_INDEX] = vec4(specularMapColor.rgb, specularMapColor.a * writeGeometryInfo);\n        #else\n            gl_FragData[PREPASS_REFLECTIVITY_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo);\n        #endif\n    #endif\n#endif\n\n#if !defined(PREPASS) || defined(WEBGL2)\n    gl_FragColor = color;\n#endif\n\n#if ORDER_INDEPENDENT_TRANSPARENCY\n    if (fragDepth == nearestDepth) {\n        frontColor.rgb += color.rgb * color.a * alphaMultiplier;\n        frontColor.a = 1.0 - alphaMultiplier * (1.0 - color.a);\n    } else {\n        backColor += color;\n    }\n#endif\n\n#define CUSTOM_FRAGMENT_MAIN_END\n\n}\n"),this.inspectableCustomProperties=this.inspectableCustomProperties||[],this.inspectableCustomProperties.push({label:"DiffuseColor",propertyName:"diffuseColor",type:g.InspectableType.Color3},{label:"AmbientColor",propertyName:"ambientColor",type:g.InspectableType.Color3},{label:"EmissiveColor",propertyName:"emissiveColor",type:g.InspectableType.Color3},{label:"ShadeColor",propertyName:"shadeColor",type:g.InspectableType.Color3},{label:"RimColor",propertyName:"rimColor",type:g.InspectableType.Color3},{label:"OutlineColor",propertyName:"outlineColor",type:g.InspectableType.Color3},{label:"ReceiveShadowRate",propertyName:"receiveShadowRate",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadingGradeRate",propertyName:"shadingGradeRate",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadeShift",propertyName:"shadeShift",type:g.InspectableType.Slider,min:-1,max:1,step:.01},{label:"ShadeToony",propertyName:"shadeToony",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"LightColorAttenuation",propertyName:"lightColorAttenuation",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"IndirectLightIntensity",propertyName:"indirectLightIntensity",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimLightingMix",propertyName:"rimLightingMix",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimFresnelPower",propertyName:"rimFresnelPower",type:g.InspectableType.Slider,min:.01,max:100,step:4},{label:"RimLift",propertyName:"rimLift",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"OutlineWidth",propertyName:"outlineWidth",type:g.InspectableType.Slider,min:.01,max:1,step:.01},{label:"OutlineScaledMaxDistance",propertyName:"outlineScaledMaxDistance",type:g.InspectableType.Slider,min:1,max:10,step:.01},{label:"OutlineLightingMix",propertyName:"outlineLightingMix",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"DebugMode",propertyName:"debugMode",type:g.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineWidthMode",propertyName:"outlineWidthMode",type:g.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineColorMode",propertyName:"outlineColorMode",type:g.InspectableType.Slider,min:0,max:1,step:1},{label:"CullMode",propertyName:"cullMode",type:g.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineCullMode",propertyName:"outlineCullMode",type:g.InspectableType.Slider,min:0,max:2,step:1},{label:"AlphaCutOff",propertyName:"alphaCutOff",type:g.InspectableType.Slider,min:0,max:1,step:.01},{label:"UV Animation Scroll X",propertyName:"uvAnimationScrollX",type:g.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Scroll Y",propertyName:"uvAnimationScrollY",type:g.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Rotation",propertyName:"uvAnimationRotation",type:g.InspectableType.Slider,min:-.5,max:.5,step:.01})}get appendedTextures(){return[this._diffuseTexture,this._emissiveTexture,this._bumpTexture,this._shadeTexture,this._receiveShadowTexture,this._shadingGradeTexture,this._rimTexture,this._matCapTexture,this._outlineWidthTexture,this._uvAnimationMaskTexture]}get appendedActiveTextures(){return this.appendedTextures.filter((e=>null!==e))}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(e){this._attachImageProcessingConfiguration(e),this._markAllSubMeshesAsTexturesDirty()}_attachImageProcessingConfiguration(e){e!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),this._imageProcessingConfiguration=e||this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add((()=>{this._markAllSubMeshesAsImageProcessingDirty()}))))}get isPrePassCapable(){return!1}get cameraColorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set cameraColorCurvesEnabled(e){this.imageProcessingConfiguration.colorCurvesEnabled=e}get cameraColorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set cameraColorGradingEnabled(e){this.imageProcessingConfiguration.colorGradingEnabled=e}get cameraToneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set cameraToneMappingEnabled(e){this._imageProcessingConfiguration.toneMappingEnabled=e}get cameraExposure(){return this._imageProcessingConfiguration.exposure}set cameraExposure(e){this._imageProcessingConfiguration.exposure=e}get cameraContrast(){return this._imageProcessingConfiguration.contrast}set cameraContrast(e){this._imageProcessingConfiguration.contrast=e}get cameraColorGradingTexture(){return this._imageProcessingConfiguration.colorGradingTexture}set cameraColorGradingTexture(e){this._imageProcessingConfiguration.colorGradingTexture=e}get cameraColorCurves(){return this._imageProcessingConfiguration.colorCurves}set cameraColorCurves(e){this._imageProcessingConfiguration.colorCurves=e}get canRenderToMRT(){return!0}get bumpScale(){return this._bumpScale}set bumpScale(e){this._bumpScale=e}get receiveShadowRate(){return this._receiveShadowRate}set receiveShadowRate(e){this._receiveShadowRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadingGradeRate(){return this._shadingGradeRate}set shadingGradeRate(e){this._shadingGradeRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadeShift(){return this._shadeShift}set shadeShift(e){this._shadeShift=Math.max(-1,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadeToony(){return this._shadeToony}set shadeToony(e){this._shadeToony=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get lightColorAttenuation(){return this._lightColorAttenuation}set lightColorAttenuation(e){this._lightColorAttenuation=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get indirectLightIntensity(){return this._indirectLightIntensity}set indirectLightIntensity(e){this._indirectLightIntensity=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get rimLightingMix(){return this._rimLightingMix}set rimLightingMix(e){this._rimLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get rimFresnelPower(){return this._rimFresnelPower}set rimFresnelPower(e){this._rimFresnelPower=Math.max(0,Math.min(100,e)),this._markAllSubMeshesAsLightsDirty()}get rimLift(){return this._rimLift}set rimLift(e){this._rimLift=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get outlineWidth(){return this._outlineWidth}set outlineWidth(e){this._outlineWidth=Math.max(.01,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()}get outlineScaledMaxDistance(){return this._outlineScaledMaxDistance}set outlineScaledMaxDistance(e){this._outlineScaledMaxDistance=Math.max(1,Math.min(10,e)),this._markAllSubMeshesAsAttributesDirty()}get outlineLightingMix(){return this._outlineLightingMix}set outlineLightingMix(e){this._outlineLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()}get uvAnimationScrollX(){return this._uvAnimationScrollX}set uvAnimationScrollX(e){this._uvAnimationScrollX=e,this._markAllSubMeshesAsMiscDirty()}get uvAnimationScrollY(){return this._uvAnimationScrollY}set uvAnimationScrollY(e){this._uvAnimationScrollY=e,this._markAllSubMeshesAsMiscDirty()}get uvAnimationRotation(){return this._uvAnimationRotation}set uvAnimationRotation(e){this._uvAnimationRotation=e,this._markAllSubMeshesAsMiscDirty()}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest=e,e?this.alphaBlend?this._transparencyMode=l.Material.MATERIAL_ALPHATESTANDBLEND:this._transparencyMode=l.Material.MATERIAL_ALPHATEST:this.alphaBlend?this._transparencyMode=l.Material.MATERIAL_ALPHABLEND:this._transparencyMode=l.Material.MATERIAL_OPAQUE,this._markAllSubMeshesAsMiscDirty()}get alphaBlend(){return this._alphaBlend}set alphaBlend(e){this._alphaBlend=e,e?(this.backFaceCulling=!0,this.alphaTest?this._transparencyMode=l.Material.MATERIAL_ALPHATESTANDBLEND:this._transparencyMode=l.Material.MATERIAL_ALPHABLEND):this.alphaTest?this._transparencyMode=l.Material.MATERIAL_ALPHATEST:this._transparencyMode=l.Material.MATERIAL_OPAQUE,this._markAllSubMeshesAsMiscDirty()}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(e){this._outlineWidthMode=e,e===N.None||this.outlineRenderer||(this.outlineRenderer=new M(this.getScene(),this)),this._markAllSubMeshesAsMiscDirty()}enableOutlineRender(){this.isOutline=1}disaableOutlineRender(){this.isOutline=0}get cullMode(){return this._cullMode}set cullMode(e){switch(this._cullMode=e,this._cullMode){case b.Off:this.backFaceCulling=!1,this.sideOrientation=l.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1;break;case b.Front:this.backFaceCulling=!0,this.sideOrientation=l.Material.CounterClockWiseSideOrientation,this.twoSidedLighting=!0;break;case b.Back:this.backFaceCulling=!0,this.sideOrientation=l.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1}this._markAllSubMeshesAsMiscDirty()}applyOutlineCullMode(){this.storedCullMode=this.cullMode,this.cullMode=this._outlineCullMode}restoreOutlineCullMode(){this.cullMode=this.storedCullMode}getOutlineRendererName(){return this.outlineRenderer?this.outlineRenderer.name:""}get hasRenderTargetTextures(){return!1}getClassName(){return"MToonMaterial"}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(e){const t=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported;this._useLogarithmicDepth!==t&&(this._useLogarithmicDepth=t,this._markAllSubMeshesAsMiscDirty())}needAlphaBlending(){return!this._disableAlphaBlending&&(this.alpha<1||this._shouldUseAlphaFromDiffuseTexture())}needAlphaTesting(){return!!this._forceAlphaTest||!!this._alphaTest||this._hasAlphaChannel()&&(null==this._transparencyMode||this._transparencyMode===l.Material.MATERIAL_ALPHATEST)}_shouldUseAlphaFromDiffuseTexture(){return null!=this._diffuseTexture&&this._diffuseTexture.hasAlpha&&this._useAlphaFromDiffuseTexture&&this._transparencyMode!==l.Material.MATERIAL_OPAQUE}_hasAlphaChannel(){return null!==this._diffuseTexture&&this._diffuseTexture.hasAlpha}getAlphaTestTexture(){return this._diffuseTexture}isReadyForSubMesh(e,t,i=!1){if(this._uniformBufferLayoutBuilt||this.buildUniformLayout(),t.effect&&this.isFrozen&&t.effect._wasPreviouslyReady&&t.effect._wasPreviouslyUsingInstances===i)return!0;t.materialDefines||(this._callbackPluginEventGeneric(p.MaterialPluginEvent.GetDefineNames,this._eventInfo),t.materialDefines=new I);const n=this.getScene(),r=t.materialDefines;if(this._isReadyForSubMesh(t))return!0;const a=n.getEngine();r._needNormals=d.MaterialHelper.PrepareDefinesForLights(n,e,r,this.specularSupported,this._maxSimultaneousLights,this._disableLighting),this.outlineWidthMode!==N.None&&(r._needNormals=!0),this.applyDefines(r),d.MaterialHelper.PrepareDefinesForMultiview(n,r);const l=this.needAlphaBlendingForMesh(e)&&n.useOrderIndependentTransparency;if(d.MaterialHelper.PrepareDefinesForOIT(n,r,l),r._areTexturesDirty){this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._cacheHasRenderTargetTextures=this._eventInfo.hasRenderTargetTextures,r._needUVs=!1;for(let e=1;e<=u.Constants.MAX_SUPPORTED_UV_SETS;++e)r["MAINUV"+e]=!1;if(n.texturesEnabled){if(!(this.isReadyForTexture(this._diffuseTexture,r,"DIFFUSE")&&this.isReadyForTexture(this._emissiveTexture,r,"EMISSIVE")&&this.isReadyForTexture(this._shadeTexture,r,"SHADE")&&this.isReadyForTexture(this._receiveShadowTexture,r,"RECEIVE_SHADOW")&&this.isReadyForTexture(this._shadingGradeTexture,r,"SHADING_GRADE")&&this.isReadyForTexture(this._rimTexture,r,"RIM")&&this.isReadyForTexture(this._matCapTexture,r,"MATCAP")&&this.isReadyForTexture(this._outlineWidthTexture,r,"OUTLINE_WIDTH")&&this.isReadyForTexture(this._uvAnimationMaskTexture,r,"UV_ANIMATION_MASK")))return!1;if(n.getEngine().getCaps().standardDerivatives&&this._bumpTexture){if(!this._bumpTexture.isReady())return!1;d.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture,r,"BUMP"),r.PARALLAX=this.useParallax,r.PARALLAXOCCLUSION=this.useParallaxOcclusion,r.OBJECTSPACE_NORMALMAP=this.useObjectSpaceNormalMap}else r.BUMP=!1,r.PARALLAX=!1,r.PARALLAXOCCLUSION=!1;r.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else r.DIFFUSE=!1,r.EMISSIVE=!1,r.SHADE=!1,r.RECEIVE_SHADOW=!1,r.SHADING_GRADE=!1,r.RIM=!1,r.MATCAP=!1,r.OUTLINE_WIDTH=!1,r.BUMP=!1,r.UV_ANIMATION_MASK=!1;r.ALPHAFROMDIFFUSE=this._shouldUseAlphaFromDiffuseTexture(),r.PREMULTIPLYALPHA=this.alphaMode===u.Constants.ALPHA_PREMULTIPLIED||this.alphaMode===u.Constants.ALPHA_PREMULTIPLIED_PORTERDUFF,r.ALPHATEST_AFTERALLALPHACOMPUTATIONS=null!==this.transparencyMode,r.ALPHABLEND=null===this.transparencyMode||this.needAlphaBlendingForMesh(e)}if(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=r,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),!this._eventInfo.isReadyForSubMesh)return!1;if(r._areImageProcessingDirty&&this._imageProcessingConfiguration){if(!this._imageProcessingConfiguration.isReady())return!1;this._imageProcessingConfiguration.prepareDefines(r)}if(this.flipU!==r.FLIP_U&&(r.FLIP_U=this.flipU,r.markAsUnprocessed()),this.flipV!==r.FLIP_V&&(r.FLIP_V=this.flipV,r.markAsUnprocessed()),d.MaterialHelper.PrepareDefinesForMisc(e,n,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(e)||this._forceAlphaTest,r),d.MaterialHelper.PrepareDefinesForFrameBoundValues(n,a,r,i,null,t.getRenderingMesh().hasThinInstances),this._eventInfo.defines=r,this._eventInfo.mesh=e,this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo),d.MaterialHelper.PrepareDefinesForAttributes(e,r,this.useVertexColor,this.useBones,this.useMorphTargets,this.useVertexAlpha,this.useBakedVertexAnimation),this._callbackPluginEventPrepareDefines(this._eventInfo),r.isDirty){const i=r._areLightsDisposed;r.markAsProcessed();const l=new f.EffectFallbacks;r.BUMP&&l.addFallback(0,"BUMP"),r.PARALLAX&&l.addFallback(1,"PARALLAX"),r.PARALLAXOCCLUSION&&l.addFallback(0,"PARALLAXOCCLUSION"),r.FOG&&l.addFallback(1,"FOG"),r.POINTSIZE&&l.addFallback(0,"POINTSIZE"),r.LOGARITHMICDEPTH&&l.addFallback(0,"LOGARITHMICDEPTH"),d.MaterialHelper.HandleFallbacksForShadows(r,l,this._maxSimultaneousLights),r.MULTIVIEW&&l.addFallback(0,"MULTIVIEW");const h=[o.VertexBuffer.PositionKind];r.NORMAL&&h.push(o.VertexBuffer.NormalKind),r.TANGENT&&h.push(o.VertexBuffer.TangentKind);for(let e=1;e<=u.Constants.MAX_SUPPORTED_UV_SETS;++e)r["UV"+e]&&h.push(`uv${1===e?"":e}`);r.INSTANCESCOLOR&&h.push(o.VertexBuffer.ColorInstanceKind),d.MaterialHelper.PrepareAttributesForBones(h,e,r,l),d.MaterialHelper.PrepareAttributesForInstances(h,r),d.MaterialHelper.PrepareAttributesForMorphTargets(h,e,r),d.MaterialHelper.PrepareAttributesForBakedVertexAnimation(h,e,r);const c="mtoon",m=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","visibility","vFogInfos","vFogColor","pointSize","mBones","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vClipPlane5","vClipPlane6","logarithmicDepthConstant","vTangentSpaceParams","alphaCutOff","boneTextureWidth","morphTargetTextureInfo","morphTargetTextureIndices","vDiffuseColor","vDiffuseInfos","diffuseMatrix","vEmissiveColor","vEmissiveInfos","emissiveMatrix","vBumpInfos","bumpMatrix","vShadeColor","vShadeInfos","shadeMatrix","vReceiveShadowInfos","receiveShadowMatrix","vShadingGradeInfos","shadingGradeMatrix","vRimColor","vRimInfos","RimMatrix","vMatCapInfos","MatCapMatrix","vOutlineColor","vOutlineWidthInfos","outlineWidthMatrix","aspect","isOutline","shadingGradeRate","receiveShadowRate","shadeShift","shadeToony","rimLightingMix","rimFresnelPower","rimLift","lightColorAttenuation","indirectLightIntensity","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","uvAnimationScrollX","uvAnimationScrollY","uvAnimationRotation","vEyeUp","time","projection"],g=["diffuseSampler","ambientSampler","emissiveSampler","bumpSampler","boneSampler","morphTargets","oitDepthSampler","oitFrontColorSampler","shadeSampler","receiveShadowSampler","shadingGradeSampler","rimSampler","matCapSampler","outlineWidthSampler","uvAnimationMaskSampler"],_=["Material","Scene","Mesh"];this._eventInfo.fallbacks=l,this._eventInfo.fallbackRank=0,this._eventInfo.defines=r,this._eventInfo.uniforms=m,this._eventInfo.attributes=h,this._eventInfo.samplers=g,this._eventInfo.uniformBuffersNames=_,this._eventInfo.customCode=void 0,this._eventInfo.mesh=e,this._callbackPluginEventGeneric(p.MaterialPluginEvent.PrepareEffect,this._eventInfo),s.ImageProcessingConfiguration&&(s.ImageProcessingConfiguration.PrepareUniforms(m,r),s.ImageProcessingConfiguration.PrepareSamplers(g,r)),d.MaterialHelper.PrepareUniformsAndSamplersList({uniformsNames:m,uniformBuffersNames:_,samplers:g,defines:r,maxSimultaneousLights:this._maxSimultaneousLights});const M={},A=r.toString(),v=t.effect;let T=n.getEngine().createEffect(c,{attributes:h,uniformsNames:m,uniformBuffersNames:_,samplers:g,defines:A,fallbacks:l,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:r.NUM_MORPH_INFLUENCERS},processFinalCode:M.processFinalCode,processCodeAfterIncludes:this._eventInfo.customCode,multiTarget:r.PREPASS},a);if(T)if(this._onEffectCreatedObservable&&(S.effect=T,S.subMesh=t,this._onEffectCreatedObservable.notifyObservers(S)),this.allowShaderHotSwapping&&v&&!T.isReady()){if(T=v,r.markAsUnprocessed(),i)return r._areLightsDisposed=!0,!1}else n.resetCachedMaterial(),t.setEffect(T,r,this._materialContext)}return!(!t.effect||!t.effect.isReady()||(r._renderId=n.getRenderId(),t.effect._wasPreviouslyReady=!0,t.effect._wasPreviouslyUsingInstances=i,0))}buildUniformLayout(){const e=this._uniformBuffer;e.addUniform("vDiffuseColor",4),e.addUniform("vDiffuseInfos",2),e.addUniform("diffuseMatrix",16),e.addUniform("vEmissiveColor",3),e.addUniform("vEmissiveInfos",2),e.addUniform("emissiveMatrix",16),e.addUniform("vBumpInfos",3),e.addUniform("bumpMatrix",16),e.addUniform("vShadeColor",3),e.addUniform("vShadeInfos",2),e.addUniform("shadeMatrix",16),e.addUniform("vReceiveShadowInfos",2),e.addUniform("receiveShadowMatrix",16),e.addUniform("vShadingGradeInfos",2),e.addUniform("shadingGradeMatrix",16),e.addUniform("vRimColor",3),e.addUniform("vRimInfos",2),e.addUniform("rimMatrix",16),e.addUniform("vMatCapInfos",2),e.addUniform("matCapMatrix",16),e.addUniform("vOutlineColor",3),e.addUniform("vOutlineWidthInfos",2),e.addUniform("outlineWidthMatrix",16),e.addUniform("vUvAnimationMaskInfos",2),e.addUniform("uvAnimationMaskMatrix",16),e.addUniform("vTangentSpaceParams",2),e.addUniform("pointSize",1),e.addUniform("shadingGradeRate",1),e.addUniform("receiveShadowRate",1),e.addUniform("shadeShift",1),e.addUniform("shadeToony",1),e.addUniform("lightColorAttenuation",1),e.addUniform("indirectLightIntensity",1),e.addUniform("rimLightingMix",1),e.addUniform("rimFresnelPower",1),e.addUniform("rimLift",1),e.addUniform("outlineWidth",1),e.addUniform("outlineScaledMaxDistance",1),e.addUniform("outlineLightingMix",1),e.addUniform("uvAnimationScrollX",1),e.addUniform("uvAnimationScrollY",1),e.addUniform("uvAnimationRotation",1),e.addUniform("vEyeUp",3),e.addUniform("alphaCutOff",1),e.addUniform("vAmbientColor",3),e.addUniform("aspect",1),e.addUniform("isOutline",1),e.addUniform("time",4),e.addUniform("visibility",1),super.buildUniformLayout()}bindForSubMesh(e,t,i){var a;const o=this.getScene(),s=i.materialDefines,l=i.effect;if(!s||!l)return;this._activeEffect=l,t.getMeshUniformBuffer().bindToEffect(l,"Mesh"),t.transferToEffect(e),this._uniformBuffer.bindToEffect(l,"Material"),this._eventInfo.subMesh=i,this._callbackPluginEventHardBindForSubMesh(this._eventInfo),s.OBJECTSPACE_NORMALMAP&&(e.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const h=this._mustRebind(o,l,t.visibility);d.MaterialHelper.BindBonesParameters(t,l);const u=this._uniformBuffer;if(h){this.bindViewProjection(l),u.useUbo&&this.isFrozen&&u.isSync||(o.texturesEnabled&&(this.bindTexture(this._diffuseTexture,u,l,"diffuse","vDiffuseInfos"),this.bindTexture(this._emissiveTexture,u,l,"emissive","vEmissiveInfos"),this._bumpTexture&&o.getEngine().getCaps().standardDerivatives&&(u.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this._bumpScale),d.MaterialHelper.BindTextureMatrix(this._bumpTexture,u,"bump"),l.setTexture("bumpSampler",this._bumpTexture),o._mirroredCameraPosition?u.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?1:-1,this._invertNormalMapY?1:-1):u.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?-1:1,this._invertNormalMapY?-1:1)),this.bindTexture(this._shadeTexture,u,l,"shade","vShadeInfos"),this.bindTexture(this._receiveShadowTexture,u,l,"receiveShadow","vReceiveShadowInfos"),this.bindTexture(this._shadingGradeTexture,u,l,"shadingGrade","vShadingGradeInfos"),this.bindTexture(this._rimTexture,u,l,"rim","vRimInfos"),this.bindTexture(this._matCapTexture,u,l,"matCap","vMatCapInfos"),this.bindTexture(this._outlineWidthTexture,u,l,"outlineWidth","vOutlineWidthInfos"),this.bindTexture(this._uvAnimationMaskTexture,u,l,"uvAnimationMask","vUvAnimationMaskInfos"),this._hasAlphaChannel()&&u.updateFloat("alphaCutOff",this.alphaCutOff)),this.pointsCloud&&u.updateFloat("pointSize",this.pointSize),u.updateFloat("receiveShadowRate",this._receiveShadowRate),u.updateFloat("shadingGradeRate",this._shadingGradeRate),u.updateFloat("shadeShift",this._shadeShift),u.updateFloat("shadeToony",this._shadeToony),u.updateFloat("lightColorAttenuation",this._lightColorAttenuation),u.updateFloat("indirectLightIntensity",this._indirectLightIntensity),u.updateFloat("rimLightingMix",this._rimLightingMix),u.updateFloat("rimFresnelPower",this._rimFresnelPower),u.updateFloat("rimLift",this._rimLift),u.updateFloat("outlineWidth",this._outlineWidth),u.updateFloat("outlineScaledMaxDistance",this._outlineScaledMaxDistance),u.updateFloat("outlineLightingMix",this._outlineLightingMix),u.updateFloat("uvAnimationScrollX",this._uvAnimationScrollX),u.updateFloat("uvAnimationScrollY",this._uvAnimationScrollY),u.updateFloat("uvAnimationRotation",this._uvAnimationRotation),o.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),u.updateColor3("vAmbientColor",this._globalAmbientColor),u.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),u.updateColor3("vEmissiveColor",this.emissiveColor),u.updateColor3("vShadeColor",this.shadeColor),u.updateColor3("vRimColor",this.rimColor),u.updateColor4("vOutlineColor",this.outlineColor,1),u.updateVector3("vEyeUp",o.activeCamera.upVector));const e=o;e.useOrderIndependentTransparency&&this.needAlphaBlendingForMesh(t)&&e.depthPeelingRenderer&&e.depthPeelingRenderer.bind(l),this._eventInfo.subMesh=i,this._callbackPluginEventBindForSubMesh(this._eventInfo),d.MaterialHelper.BindClipPlane(l,o),this.bindEyePosition(l)}else o.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0);if(h||!this.isFrozen){o.lightsEnabled&&!this._disableLighting&&d.MaterialHelper.BindLights(o,t,l,s,this._maxSimultaneousLights),(o.fogEnabled&&t.applyFog&&o.fogMode!==n.Scene.FOGMODE_NONE||t.receiveShadows)&&this.bindView(l),d.MaterialHelper.BindFogParameters(o,t,l),s.NUM_MORPH_INFLUENCERS&&d.MaterialHelper.BindMorphTargetParameters(t,l),s.BAKED_VERTEX_ANIMATION_TEXTURE&&(null===(a=t.bakedVertexAnimationManager)||void 0===a||a.bind(l,s.INSTANCES)),this.useLogarithmicDepth&&d.MaterialHelper.BindLogDepth(s,l,o),this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.applyByPostProcess&&this._imageProcessingConfiguration.bind(this._activeEffect),u.updateFloat("aspect",o.getEngine().getAspectRatio(o.activeCamera)),u.updateFloat("isOutline",this.isOutline);const e=window.performance.now()/1e3;u.updateVector4("time",new r.Vector4(e/20,e,2*e,3*e))}this._afterBind(t,this._activeEffect),u.update()}getAnimatables(){const e=super.getAnimatables();for(const t of this.appendedActiveTextures)t.animations&&t.animations.length>0&&e.push(t);return e}getActiveTextures(){return super.getActiveTextures().concat(this.appendedActiveTextures)}hasTexture(e){if(super.hasTexture(e))return!0;for(const t of this.appendedActiveTextures)if(t===e)return!0;return!1}dispose(e,t){if(delete this.outlineRenderer,t)for(const e of this.appendedActiveTextures)e.dispose();this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),super.dispose(e,t)}clone(e){const i=t.SerializationHelper.Clone((()=>new D(e,this.getScene())),this);return i.name=e,i.id=e,this.stencil.copyTo(i.stencil),i}static Parse(e,i,n){const r=t.SerializationHelper.Parse((()=>new D(e.name,i)),e,i,n);return e.stencil&&r.stencil.parse(e.stencil,i,n),r}bindTexture(e,t,i,n,r){e&&(this._uniformBuffer.updateFloat2(r,e.coordinatesIndex,e.level),d.MaterialHelper.BindTextureMatrix(e,t,n),i.setTexture(`${n}Sampler`,e))}isReadyForTexture(e,t,i){return e?!!e.isReadyOrNotBlocking()&&(d.MaterialHelper.PrepareDefinesForMergedUV(e,t,i),!0):(t[i]=!1,!0)}applyDefines(e){switch(this._debugMode){case E.Normal:!0!==e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!0,e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed());break;case E.LitShadeRate:!0!==e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_NORMAL=!1,e.MTOON_DEBUG_LITSHADERATE=!0,e.markAsUnprocessed());break;case E.None:!0===e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!1,e.markAsUnprocessed()),!0===e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed())}switch(this.outlineWidthMode){case N.WorldCorrdinates:!0!==e.MTOON_OUTLINE_WIDTH_WORLD&&(e.MTOON_OUTLINE_WIDTH_WORLD=!0,e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.markAsUnprocessed());break;case N.ScreenCoordinates:!0!==e.MTOON_OUTLINE_WIDTH_SCREEN&&(e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.MTOON_OUTLINE_WIDTH_SCREEN=!0,e.markAsUnprocessed());break;case N.None:!1===e.MTOON_OUTLINE_WIDTH_SCREEN&&!1===e.MTOON_OUTLINE_WIDTH_WORLD||(e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.markAsUnprocessed())}switch(this.outlineColorMode){case x.FixedColor:!0!==e.MTOON_OUTLINE_COLOR_FIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!0,e.MTOON_OUTLINE_COLOR_MIXED=!1,e.markAsUnprocessed());break;case x.MixedLighting:!0!==e.MTOON_OUTLINE_COLOR_MIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!1,e.MTOON_OUTLINE_COLOR_MIXED=!0,e.markAsUnprocessed())}}}e([(0,t.serializeAsTexture)("diffuseTexture")],D.prototype,"_diffuseTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],D.prototype,"diffuseTexture",void 0),e([(0,t.serializeAsTexture)("emissiveTexture")],D.prototype,"_emissiveTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"emissiveTexture",void 0),e([(0,t.serializeAsTexture)("bumpTexture")],D.prototype,"_bumpTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"bumpTexture",void 0),e([(0,t.serializeAsTexture)("shadeTexture")],D.prototype,"_shadeTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"shadeTexture",void 0),e([(0,t.serializeAsTexture)("receiveShadowTexture")],D.prototype,"_receiveShadowTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"receiveShadowTexture",void 0),e([(0,t.serializeAsTexture)("shadingGradeTexture")],D.prototype,"_shadingGradeTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"shadingGradeTexture",void 0),e([(0,t.serializeAsTexture)("rimTexture")],D.prototype,"_rimTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"rimTexture",void 0),e([(0,t.serializeAsTexture)("matCapTexture")],D.prototype,"_matCapTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"matCapTexture",void 0),e([(0,t.serializeAsTexture)("outlineWidthTexture")],D.prototype,"_outlineWidthTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"outlineWidthTexture",void 0),e([(0,t.serializeAsTexture)("outlineWidthTexture")],D.prototype,"_uvAnimationMaskTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"uvAnimationMaskTexture",void 0),e([(0,t.serializeAsColor3)("diffuse")],D.prototype,"diffuseColor",void 0),e([(0,t.serialize)("ambient")],D.prototype,"ambientColor",void 0),e([(0,t.serialize)("emissive")],D.prototype,"emissiveColor",void 0),e([(0,t.serialize)("shade")],D.prototype,"shadeColor",void 0),e([(0,t.serialize)("rim")],D.prototype,"rimColor",void 0),e([(0,t.serialize)("outline")],D.prototype,"outlineColor",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"useEmissiveAsIllumination",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"linkEmissiveWithDiffuse",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"useReflectionOverAlpha",void 0),e([(0,t.serialize)("disableLighting")],D.prototype,"_disableLighting",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsLightsDirty")],D.prototype,"disableLighting",void 0),e([(0,t.serialize)()],D.prototype,"alphaCutOff",void 0),e([(0,t.serialize)("useAlphaFromDiffuseTexture")],D.prototype,"_useAlphaFromDiffuseTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],D.prototype,"useAlphaFromDiffuseTexture",void 0),e([(0,t.serialize)("maxSimultaneousLights")],D.prototype,"_maxSimultaneousLights",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsLightsDirty")],D.prototype,"maxSimultaneousLights",void 0),e([(0,t.serialize)("invertNormalMapX")],D.prototype,"_invertNormalMapX",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"invertNormalMapX",void 0),e([(0,t.serialize)("invertNormalMapY")],D.prototype,"_invertNormalMapY",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"invertNormalMapY",void 0),e([(0,t.serialize)("twoSidedLighting")],D.prototype,"_twoSidedLighting",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],D.prototype,"twoSidedLighting",void 0),e([(0,t.serialize)()],D.prototype,"bumpScale",null),e([(0,t.serialize)()],D.prototype,"receiveShadowRate",null),e([(0,t.serialize)()],D.prototype,"shadingGradeRate",null),e([(0,t.serialize)()],D.prototype,"shadeShift",null),e([(0,t.serialize)()],D.prototype,"shadeToony",null),e([(0,t.serialize)()],D.prototype,"lightColorAttenuation",null),e([(0,t.serialize)()],D.prototype,"indirectLightIntensity",null),e([(0,t.serialize)()],D.prototype,"rimLightingMix",null),e([(0,t.serialize)()],D.prototype,"rimFresnelPower",null),e([(0,t.serialize)()],D.prototype,"rimLift",null),e([(0,t.serialize)()],D.prototype,"outlineWidth",null),e([(0,t.serialize)()],D.prototype,"outlineScaledMaxDistance",null),e([(0,t.serialize)()],D.prototype,"outlineLightingMix",null),e([(0,t.serialize)()],D.prototype,"uvAnimationScrollX",null),e([(0,t.serialize)()],D.prototype,"uvAnimationScrollY",null),e([(0,t.serialize)()],D.prototype,"uvAnimationRotation",null),e([(0,t.serialize)("alphaTest")],D.prototype,"_alphaTest",void 0),e([(0,t.serialize)()],D.prototype,"alphaTest",null),e([(0,t.serialize)()],D.prototype,"alphaBlend",null),e([(0,t.serialize)("debugMode")],D.prototype,"_debugMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],D.prototype,"debugMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],D.prototype,"outlineColorMode",void 0),e([(0,t.serialize)()],D.prototype,"cullMode",null),e([(0,t.serialize)()],D.prototype,"_outlineCullMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],D.prototype,"outlineCullMode",void 0),e([(0,t.serialize)("flipU")],D.prototype,"flipU",void 0),e([(0,t.serialize)("flipV")],D.prototype,"flipV",void 0),e([(0,t.serialize)()],D.prototype,"useLogarithmicDepth",null)})(),T})(),e.exports=n(i(388),i(474),i(538),i(694),i(548),i(908),i(677),i(66),i(721),i(221),i(556),i(55),i(272),i(824),i(628),i(812),i(667),i(713))},235:e=>{"use strict";e.exports=t},908:e=>{"use strict";e.exports=s},556:e=>{"use strict";e.exports=f},4:e=>{"use strict";e.exports=T},6:e=>{"use strict";e.exports=x},272:e=>{"use strict";e.exports=m},55:e=>{"use strict";e.exports=c},677:e=>{"use strict";e.exports=l},66:e=>{"use strict";e.exports=h},824:e=>{"use strict";e.exports=p},713:e=>{"use strict";e.exports=A},221:e=>{"use strict";e.exports=u},628:e=>{"use strict";e.exports=g},721:e=>{"use strict";e.exports=d},53:e=>{"use strict";e.exports=S},197:t=>{"use strict";t.exports=e},548:e=>{"use strict";e.exports=o},694:e=>{"use strict";e.exports=a},705:e=>{"use strict";e.exports=I},564:e=>{"use strict";e.exports=E},388:e=>{"use strict";e.exports=i},812:e=>{"use strict";e.exports=_},474:e=>{"use strict";e.exports=n},538:e=>{"use strict";e.exports=r},667:e=>{"use strict";e.exports=M},606:e=>{"use strict";e.exports=v},746:e=>{"use strict";e.exports=N}},D={};function C(e){var t=D[e];if(void 0!==t)return t.exports;var i=D[e]={exports:{}};return b[e](i,i.exports,C),i.exports}C.d=(e,t)=>{for(var i in t)C.o(t,i)&&!C.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},C.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),C.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var L={};return(()=>{"use strict";C.r(L),C.d(L,{BoneNotFoundError:()=>e,HumanoidBone:()=>t,IVRMMaterialPropertyShader:()=>d,MaterialValueBindingMerger:()=>h,VCAST_vci_material_unity:()=>g,VRM:()=>w,VRMFileLoader:()=>U,VRMManager:()=>R,VRMMaterialGenerator:()=>c});class e extends Error{constructor(e){super(`Bone:${e} NotFound`),this.boneName=e,this.name="BoneNotFoundError"}}class t{constructor(e){this.nodeMap=e}dispose(){this.nodeMap=null}get hips(){return this.getMandatoryBone("hips")}get leftUpperLeg(){return this.getMandatoryBone("leftUpperLeg")}get rightUpperLeg(){return this.getMandatoryBone("rightUpperLeg")}get leftLowerLeg(){return this.getMandatoryBone("leftLowerLeg")}get rightLowerLeg(){return this.getMandatoryBone("rightLowerLeg")}get leftFoot(){return this.getMandatoryBone("leftFoot")}get rightFoot(){return this.getMandatoryBone("rightFoot")}get spine(){return this.getMandatoryBone("spine")}get chest(){return this.getMandatoryBone("chest")}get neck(){return this.getMandatoryBone("neck")}get head(){return this.getMandatoryBone("head")}get leftShoulder(){return this.getMandatoryBone("leftShoulder")}get rightShoulder(){return this.getMandatoryBone("rightShoulder")}get leftUpperArm(){return this.getMandatoryBone("leftUpperArm")}get rightUpperArm(){return this.getMandatoryBone("rightUpperArm")}get leftLowerArm(){return this.getMandatoryBone("leftLowerArm")}get rightLowerArm(){return this.getMandatoryBone("rightLowerArm")}get leftHand(){return this.getMandatoryBone("leftHand")}get rightHand(){return this.getMandatoryBone("rightHand")}get leftToes(){return this.getOptionalBone("leftToes")}get rightToes(){return this.getOptionalBone("rightToes")}get leftEye(){return this.getOptionalBone("leftEye")}get rightEye(){return this.getOptionalBone("rightEye")}get jaw(){return this.getOptionalBone("jaw")}get leftThumbProximal(){return this.getOptionalBone("leftThumbProximal")}get leftThumbIntermediate(){return this.getOptionalBone("leftThumbIntermediate")}get leftThumbDistal(){return this.getOptionalBone("leftThumbDistal")}get leftIndexProximal(){return this.getOptionalBone("leftIndexProximal")}get leftIndexIntermediate(){return this.getOptionalBone("leftIndexIntermediate")}get leftIndexDistal(){return this.getOptionalBone("leftIndexDistal")}get leftMiddleProximal(){return this.getOptionalBone("leftMiddleProximal")}get leftMiddleIntermediate(){return this.getOptionalBone("leftMiddleIntermediate")}get leftMiddleDistal(){return this.getOptionalBone("leftMiddleDistal")}get leftRingProximal(){return this.getOptionalBone("leftRingProximal")}get leftRingIntermediate(){return this.getOptionalBone("leftRingIntermediate")}get leftRingDistal(){return this.getOptionalBone("leftRingDistal")}get leftLittleProximal(){return this.getOptionalBone("leftLittleProximal")}get leftLittleIntermediate(){return this.getOptionalBone("leftLittleIntermediate")}get leftLittleDistal(){return this.getOptionalBone("leftLittleDistal")}get rightThumbProximal(){return this.getOptionalBone("rightThumbProximal")}get rightThumbIntermediate(){return this.getOptionalBone("rightThumbIntermediate")}get rightThumbDistal(){return this.getOptionalBone("rightThumbDistal")}get rightIndexProximal(){return this.getOptionalBone("rightIndexProximal")}get rightIndexIntermediate(){return this.getOptionalBone("rightIndexIntermediate")}get rightIndexDistal(){return this.getOptionalBone("rightIndexDistal")}get rightMiddleProximal(){return this.getOptionalBone("rightMiddleProximal")}get rightMiddleIntermediate(){return this.getOptionalBone("rightMiddleIntermediate")}get rightMiddleDistal(){return this.getOptionalBone("rightMiddleDistal")}get rightRingProximal(){return this.getOptionalBone("rightRingProximal")}get rightRingIntermediate(){return this.getOptionalBone("rightRingIntermediate")}get rightRingDistal(){return this.getOptionalBone("rightRingDistal")}get rightLittleProximal(){return this.getOptionalBone("rightLittleProximal")}get rightLittleIntermediate(){return this.getOptionalBone("rightLittleIntermediate")}get rightLittleDistal(){return this.getOptionalBone("rightLittleDistal")}get upperChest(){return this.getOptionalBone("upperChest")}getMandatoryBone(t){const i=this.nodeMap[t];if(!i)throw new e(t);return i}getOptionalBone(e){return this.nodeMap&&this.nodeMap[e]||null}}var i=C(197),n=C(235),r=C(838);const a={_MainTex:"albedoTexture"},o={_Color:"albedoColor"},s={_MainTex:"diffuseTexture",_EmissionMap:"emissiveTexture",_BumpMap:"bumpTexture",_ShadeTexture:"shadeTexture",_ReceiveShadowTexture:"receiveShadowTexture",_ShadingGradeTexture:"shadingGradeTexture",_RimTexture:"rimTexture",_SphereAdd:"matCapTexture",_OutlineWidthTexture:"outlineWidthTexture",_UvAnimMaskTexture:"uvAnimationMaskTexture"},l={_Color:"diffuseColor",_ShadeColor:"shadeColor",_RimColor:"rimColor",_EmissionColor:"emissiveColor",_OutlineColor:"outlineColor"};class h{constructor(e,t){this.materialValues=t,this.m_materialMap={},this.m_materialSetterMap={},this.m_materialValueMap={},this.m_used={},this.baseValueCache={},this.materialValuesToApply={},0!==e.length&&0!==t.length&&(e.forEach((e=>{(e instanceof r.MToonMaterial||e instanceof n.PBRMaterial)&&(this.m_materialMap[e.name]=e)})),t.forEach((e=>{const t=this.makeBindingKey(e);if(this.m_materialSetterMap[t])return;const r=this.m_materialMap[e.materialName];if(!r)return;const o=this.getMaterialProperty(r,e.propertyName);if(!o||4!==e.targetValue.length)return;this.baseValueCache[t]=o,this.materialValuesToApply[t]=e;const l=i.Vector4.FromArray(e.targetValue),h=e.propertyName;if(r instanceof n.PBRMaterial?Object.keys(a).some((e=>h.startsWith(e)))&&(l.w*=-1):Object.keys(s).some((e=>h.startsWith(e)))&&(l.w*=-1),h.endsWith("_ST_S")){const e=(e,t)=>{const i=t?o.add(l.subtract(o).scale(e)):this.getMaterialProperty(r,h).add(l.subtract(o).scale(e)),n=this.getMaterialProperty(r,h);n.x=i.x,n.z=i.z,this.updateMaterialProperty(r,h,n)};this.m_materialSetterMap[t]=e}else if(h.endsWith("_ST_T")){const e=(e,t)=>{const i=t?o.add(l.subtract(o).scale(e)):this.getMaterialProperty(r,h).add(l.subtract(o).scale(e)),n=this.getMaterialProperty(r,h);n.y=i.y,n.w=i.w,this.updateMaterialProperty(r,h,n)};this.m_materialSetterMap[t]=e}else{const e=(e,t)=>{const i=t?o.add(l.subtract(o).scale(e)):this.getMaterialProperty(r,h).add(l.subtract(o).scale(e));this.updateMaterialProperty(r,h,i)};this.m_materialSetterMap[t]=e}})))}makeBindingKey(e){return`${e.materialName}_${e.propertyName}_${e.targetValue.join("-")}`}makeTargetKey(e){return`${e.materialName}_${e.propertyName}`}morphing(e){this.accumulateValue(e),this.apply()}accumulateValue(e){this.materialValues.forEach((t=>{const i=this.makeBindingKey(t);this.m_materialValueMap[i]?this.m_materialValueMap[i]+=e:this.m_materialValueMap[i]=e}))}apply(){this.m_used={},Object.entries(this.materialValuesToApply).forEach((([e,t])=>{const i=this.makeTargetKey(t);if(!(i in this.m_used)){const n=this.m_materialMap[t.materialName],r=this.baseValueCache[e].clone(),a=t.propertyName;if(a.endsWith("_ST_S")){const e=this.getMaterialProperty(n,a);r.y=e.y,r.w=e.w}else if(a.endsWith("_ST_T")){const e=this.getMaterialProperty(n,a);r.x=e.x,r.z=e.z}this.updateMaterialProperty(n,a,r),this.m_used[i]=!0}const n=this.m_materialSetterMap[e];n&&n(this.m_materialValueMap[e],!1)})),this.m_materialValueMap={}}getMaterialProperty(e,t){const i=t.match(/^(_[^_]+)/);if(!i||!i[1])return null;const r=i[1];return e instanceof n.PBRMaterial?a[r]?this.convertTextureIntoVector4WhenNotNull(e[a[r]]):o[r]?this.convertColorIntoVector4(e[o[r]],e.alpha):null:s[r]?this.convertTextureIntoVector4WhenNotNull(e[s[r]]):l[r]?this.convertColorIntoVector4(e[l[r]],e.alpha):null}convertTextureIntoVector4WhenNotNull(e){if(!e)return null;const t=e;return new i.Vector4(t.uScale,t.vScale,t.uOffset,t.vOffset)}convertColorIntoVector4(e,t){return new i.Vector4(e.r,e.g,e.b,t)}updateMaterialProperty(e,t,i){const r=t.match(/^(_[^_]+)/);if(!r||!r[1])return;const h=r[1];if(e instanceof n.PBRMaterial)return a[h]?void this.updateTextureWhenNotNull(e[a[h]],i):void(o[h]&&("_Color"===h&&(e.alpha=i.w),this.updateColor(e[o[h]],i)));s[h]?this.updateTextureWhenNotNull(e[s[h]],i):l[h]&&("_Color"===h&&(e.alpha=i.w),this.updateColor(e[l[h]],i))}updateTextureWhenNotNull(e,t){if(e){const i=e;i.uScale=t.x,i.vScale=t.y,i.uOffset=t.z,i.vOffset=t.w}}updateColor(e,t){e.r=t.x,e.g=t.y,e.b=t.z}}var d,u=C(606);!function(e){e.VRM_USE_GLTFSHADER="VRM_USE_GLTFSHADER",e.VRMMToon="VRM/MToon",e.VRMUnlitTransparentZWrite="VRM/UnlitTransparentZWrite"}(d||(d={}));var f=C(4);class c{constructor(e){this.loader=e}generate(e,t,i,n,a){const o=this.findMaterialPropertyByName(t.name,this.getMaterialProperties());if(!o)return null;i.alphaIndex=o.renderQueue;const s=this.createMaterialByShader(e,t,n,o);return s?(a(s),s instanceof r.MToonMaterial?this.loadMToonTexturesAsync(e,s,o):Promise.resolve(s)):null}getMaterialProperties(){return this.loader.gltf.extensions?this.loader.gltf.extensions.VRM&&this.loader.gltf.extensions.VRM.materialProperties?this.loader.gltf.extensions.VRM.materialProperties:this.loader.gltf.extensions.VCAST_vci_material_unity&&this.loader.gltf.extensions.VCAST_vci_material_unity.materials?this.loader.gltf.extensions.VCAST_vci_material_unity.materials:[]:[]}findMaterialPropertyByName(e,t){if(!e||!t)return null;const i=t.filter((t=>t.name===e));return 0===i.length?null:(i.length>=2&&this.loader.log(`Duplicated vrm material name found: ${e}`),i[i.length-1])}loadMToonTexturesAsync(e,t,i){const n=[],r=i.vectorProperties._MainTex;if(!r)return Promise.resolve(t);const a=(t,i)=>{m(t,(a=>{n.push(this.loader.loadTextureInfoAsync(`${e}/textures/${t}`,{index:a},(e=>{const t=e;t.uOffset=r[0],t.vOffset=r[1],t.uScale=r[2],t.vScale=r[3],i(e)})))}))};return a(i.textureProperties._MainTex,(e=>{(t.alphaBlend||t.alphaTest)&&(e.hasAlpha=!0),t.diffuseTexture=e})),a(i.textureProperties._ShadeTexture,(e=>t.shadeTexture=e)),a(i.textureProperties._BumpMap,(e=>t.bumpTexture=e)),a(i.textureProperties._ReceiveShadowTexture,(e=>t.receiveShadowTexture=e)),a(i.textureProperties._ShadingGradeTexture,(e=>t.shadingGradeTexture=e)),a(i.textureProperties._RimTexture,(e=>t.rimTexture=e)),a(i.textureProperties._SphereAdd,(e=>t.matCapTexture=e)),a(i.textureProperties._EmissionMap,(e=>t.emissiveTexture=e)),a(i.textureProperties._OutlineWidthTexture,(e=>t.outlineWidthTexture=e)),a(i.textureProperties._UvAnimMaskTexture,(e=>t.uvAnimationMaskTexture=e)),Promise.all(n).then((()=>t))}createMaterialByShader(e,t,i,n){if(n.shader===d.VRMMToon){const e=new r.MToonMaterial(t.name||`MToonMaterial${t.index}`,this.loader.babylonScene);return this.setMToonMaterialProperties(e,n),e}if(n.shader===d.VRMUnlitTransparentZWrite){const n=this.loader.createMaterial(e,t,i);return n.disableDepthWrite=!1,n.forceDepthWrite=!0,n}return null}setMToonMaterialProperties(e,t){m(t.floatProperties._Cutoff,(t=>e.alphaCutOff=t)),m(t.vectorProperties._Color,(t=>{e.diffuseColor=new i.Color3(t[0],t[1],t[2]),e.alpha=t[3]})),m(t.vectorProperties._ShadeColor,(t=>{e.shadeColor=new i.Color3(t[0],t[1],t[2])})),m(t.floatProperties._BumpScale,(t=>e.bumpScale=t)),m(t.floatProperties._ReceiveShadowRate,(t=>e.receiveShadowRate=t)),m(t.floatProperties._ShadingGradeRate,(t=>e.shadingGradeRate=t)),m(t.floatProperties._ShadeShift,(t=>e.shadeShift=t)),m(t.floatProperties._ShadeToony,(t=>e.shadeToony=t)),m(t.floatProperties._LightColorAttenuation,(t=>e.lightColorAttenuation=t)),m(t.floatProperties._IndirectLightIntensity,(t=>e.indirectLightIntensity=t)),m(t.vectorProperties._RimColor,(t=>{e.rimColor=new i.Color3(t[0],t[1],t[2])})),m(t.floatProperties._RimLightingMix,(t=>e.rimLightingMix=t)),m(t.floatProperties._RimFresnelPower,(t=>e.rimFresnelPower=t)),m(t.floatProperties._RimLift,(t=>e.rimLift=t)),m(t.vectorProperties._EmissionColor,(t=>{e.emissiveColor=new i.Color3(t[0],t[1],t[2])})),m(t.floatProperties._OutlineWidth,(t=>e.outlineWidth=t)),m(t.floatProperties._OutlineScaledMaxDistance,(t=>e.outlineScaledMaxDistance=t)),m(t.vectorProperties._OutlineColor,(t=>{e.outlineColor=new i.Color3(t[0],t[1],t[2])})),m(t.floatProperties._OutlineLightingMix,(t=>e.outlineLightingMix=t)),m(t.floatProperties._UvAnimScrollX,(t=>e.uvAnimationScrollX=t)),m(t.floatProperties._UvAnimScrollY,(t=>e.uvAnimationScrollY=t)),m(t.floatProperties._UvAnimRotation,(t=>e.uvAnimationRotation=t)),m(t.floatProperties._DebugMode,(t=>e.debugMode=t)),m(t.floatProperties._BlendMode,(t=>{switch(t){case 0:e.alphaBlend=!1,e.alphaTest=!1;break;case 1:e.alphaBlend=!1,e.alphaTest=!0,e.alphaMode=f.Engine.ALPHA_COMBINE;break;case 2:e.alphaBlend=!0,e.alphaTest=!1,e.alphaMode=f.Engine.ALPHA_COMBINE}})),m(t.floatProperties._OutlineWidthMode,(t=>e.outlineWidthMode=t)),m(t.floatProperties._OutlineColorMode,(t=>e.outlineColorMode=t)),m(t.floatProperties._CullMode,(t=>e.cullMode=t)),m(t.floatProperties._OutlineCullMode,(t=>e.outlineCullMode=t)),m(t.keywordMap._ALPHABLEND_ON,(t=>e.alphaBlend=t)),m(t.keywordMap._ALPHATEST_ON,(t=>e.alphaTest=t)),m(t.floatProperties._ZWrite,(t=>{e.forceDepthWrite=1===Math.round(t),e.forceDepthWrite&&(e.disableDepthWrite=!1)}))}}function m(e,t){void 0!==e&&t(e)}const p="VCAST_vci_material_unity";class g{constructor(e){this.loader=e,this.name=p,this.enabled=!0}dispose(){this.loader=null}_loadMaterialAsync(e,t,i,n,r){return new c(this.loader).generate(e,t,i,n,r)}}u.GLTFLoader.RegisterExtension(p,(e=>new g(e)));var _=C(705);class M{constructor(e,t,i){this.offset=e,this.radius=t,this.sphere=i}}class A{constructor(e){this.transform=e,this.colliders=[]}addCollider(e,t){const i=_.SphereBuilder.CreateSphere(`${this.transform.name}_ColliderSphere`,{segments:6,diameter:2*t,updatable:!0},this.transform.getScene());i.setParent(this.transform),i.setPositionWithLocalVector(e),i.setEnabled(!1),this.colliders.push(new M(e,t,i))}}var v=C(53),T=C(564);const I=i.Matrix.Identity(),S=new i.Vector3,E=new i.Vector3,x=new i.Vector3,N=new i.Quaternion,b=new i.Matrix,D=new i.Matrix;class P{constructor(e,t,n){this.center=e,this.radius=t,this.transform=n,this.currentTail=new i.Vector3,this.prevTail=new i.Vector3,this.nextTail=new i.Vector3,n.rotationQuaternion||(n.rotationQuaternion=n.rotation.toQuaternion());const r=n.getWorldMatrix();this.centerSpacePosition=r.getTranslation(),this.initialLocalMatrix=n._localMatrix.clone(),this.initialLocalRotation=n.rotationQuaternion.clone();const a=n.getChildTransformNodes(!0);0===a.length?this.initialLocalChildPosition=n.position.clone().normalize().scaleInPlace(.07):this.initialLocalChildPosition=a[0].position.clone(),i.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,r,this.currentTail),this.prevTail.copyFrom(this.currentTail),this.nextTail.copyFrom(this.currentTail),this.boneAxis=this.initialLocalChildPosition.normalizeToNew(),i.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,r,S),this.centerSpaceBoneLength=S.subtractInPlace(this.centerSpacePosition).length(),e&&(this.getMatrixWorldToCenter(b),i.Vector3.TransformCoordinatesToRef(this.currentTail,b,this.currentTail),i.Vector3.TransformCoordinatesToRef(this.prevTail,b,this.prevTail),i.Vector3.TransformCoordinatesToRef(this.nextTail,b,this.nextTail),r.multiplyToRef(b,b),b.getTranslationToRef(this.centerSpacePosition),i.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,b,S),this.centerSpaceBoneLength=S.subtractInPlace(this.centerSpacePosition).length())}update(e,t,n,r){if(Number.isNaN(this.transform.getAbsolutePosition().x))return;this.getMatrixWorldToCenter(b),this.transform.getWorldMatrix().multiplyToRef(b,b),b.getTranslationToRef(this.centerSpacePosition),this.getMatrixWorldToCenter(D),this.getParentMatrixWorld().multiplyToRef(D,D),this.nextTail.copyFrom(this.currentTail),S.copyFrom(this.currentTail).subtractInPlace(this.prevTail).scaleInPlace(1-t),this.nextTail.addInPlace(S),S.copyFrom(this.boneAxis),i.Vector3.TransformCoordinatesToRef(S,this.initialLocalMatrix,S),i.Vector3.TransformCoordinatesToRef(S,D,S),S.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(e),this.nextTail.addInPlace(S),this.nextTail.addInPlace(n),this.nextTail.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition),this.collide(r,this.nextTail),this.prevTail.copyFrom(this.currentTail),this.currentTail.copyFrom(this.nextTail),this.initialLocalMatrix.multiplyToRef(D,b);const a=b.invert();i.Vector3.TransformCoordinatesToRef(this.nextTail,a,S),S.normalizeToRef(E),i.Quaternion.FromUnitVectorsToRef(this.boneAxis,E,N);const o=N;this.initialLocalRotation.multiplyToRef(o,this.transform.rotationQuaternion),this.transform.computeWorldMatrix(!0)}getMatrixWorldToCenter(e){return this.center?this.center.getWorldMatrix().invertToRef(e):e.copyFrom(I),e}getParentMatrixWorld(){return this.transform.parent?this.transform.parent.getWorldMatrix():I}collide(e,t){e.forEach((e=>{e.colliders.forEach((e=>{this.getMatrixWorldToCenter(b),e.sphere.computeWorldMatrix().multiplyToRef(b,b),b.getTranslationToRef(S);const i=S;let n=0;e.sphere.absoluteScaling.asArray().forEach((e=>{n=Math.max(n,Math.abs(e))}));const r=e.radius*n,a=this.radius+r;if(t.subtractToRef(i,E),E.lengthSquared()<=a*a){const e=E.copyFrom(t).subtractInPlace(i).normalize(),n=x.copyFrom(i).addInPlace(e.scaleInPlace(a));t.copyFrom(n.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition))}}))}))}}class y{constructor(e,t,i,n,r,a,o,s,l){this.comment=e,this.stiffness=t,this.gravityPower=i,this.gravityDir=n,this.dragForce=r,this.center=a,this.hitRadius=o,this.bones=s,this.colliderGroups=l,this.verlets=[],this.activeBones=[],this.drawGizmo=!1,this.activeBones=this.bones.filter((e=>null!==e)),this.activeBones.forEach((e=>{[e].concat(e.getChildTransformNodes()).forEach((e=>{this.verlets.push(new P(this.center,this.hitRadius,e))}))})),this.drawGizmo&&this.setupGizmo()}setupGizmo(){this.activeBones.forEach((e=>{const t=e.getScene();[e].concat(e.getChildTransformNodes()).forEach((e=>{const n=T.MeshBuilder.CreateSphere(e.name+"_boneGizmo",{segments:6,diameter:2*this.hitRadius,updatable:!0},t),r=new v.StandardMaterial(e.name+"_boneGizmomat",t);r.emissiveColor=i.Color3.Red(),r.wireframe=!0,n.material=r,n.setParent(e),n.position=i.Vector3.Zero()}))})),this.colliderGroups.forEach((e=>{const t=e.transform.getScene();e.colliders.forEach((n=>{const r=n.sphere;if(!r.isEnabled(!1)){r.setEnabled(!0);const n=new v.StandardMaterial(e.transform.name+"_colliderGizmomat",t);n.emissiveColor=i.Color3.Yellow(),n.wireframe=!0,r.material=n}}))}))}async update(e){const t=this.stiffness*e,i=this.gravityDir.scale(this.gravityPower*e),n=this.verlets.map((e=>new Promise((n=>{e.update(t,this.dragForce,i,this.colliderGroups),n()}))));return Promise.all(n).then((()=>{}))}}class O{constructor(e,t){this.ext=e;const i=this.constructColliderGroups(t);this.springs=this.constructSprings(t,i)}dispose(){this.springs=[]}async update(e){e=Math.max(0,Math.min(16.666,e))/1e3;const t=this.springs.map((t=>t.update(e)));return Promise.all(t).then((()=>{}))}constructColliderGroups(e){if(!this.ext.colliderGroups||!this.ext.colliderGroups.length)return[];const t=[];return this.ext.colliderGroups.forEach((n=>{const r=e(n.node),a=new A(r);n.colliders.forEach((e=>{a.addCollider(new i.Vector3(-e.offset.x,e.offset.y,-e.offset.z),e.radius)})),t.push(a)})),t}constructSprings(e,t){if(!this.ext.boneGroups||!this.ext.boneGroups.length)return[];const n=[];return this.ext.boneGroups.forEach((r=>{const a=(r.bones||[]).map((t=>e(t))),o=(r.colliderGroups||[]).map((e=>t[e]));n.push(new y(r.comment,r.stiffiness,r.gravityPower,new i.Vector3(-r.gravityDir.x,r.gravityDir.y,-r.gravityDir.z).normalize(),r.dragForce,e(r.center),r.hitRadius,a,o))})),n}}class R{constructor(e,i,n,r,a){this.ext=e,this.scene=i,this.meshesFrom=n,this.transformNodesFrom=r,this.materialsNodesFrom=a,this.isBinaryMorphMap={},this.morphTargetMap={},this.materialValueBindingMergerMap={},this.presetMorphTargetMap={},this.transformNodeMap={},this.transformNodeCache={},this.meshCache={},this.meshCache=this.constructMeshCache(),this.transformNodeCache=this.constructTransformNodeCache(),this.springBoneController=new O(this.ext.secondaryAnimation,this.findTransformNode.bind(this)),this.ext.blendShapeMaster&&this.ext.blendShapeMaster.blendShapeGroups&&(this.constructIsBinaryMap(),this.constructMorphTargetMap(),this.constructMaterialValueBindingMergerMap()),this.constructTransformNodeMap(),this._humanoidBone=new t(this.transformNodeMap)}async update(e){await this.springBoneController.update(e)}dispose(){this.springBoneController.dispose(),this._humanoidBone.dispose(),this.morphTargetMap=null,this.materialValueBindingMergerMap=null,this.presetMorphTargetMap=null,this.transformNodeMap=null,this.transformNodeCache=null,this.meshCache=null,this._rootMesh=null}morphing(e,t){const i=this.calcMorphValue(e,t);this.morphTargetMap[e]&&this.morphTargetMap[e].forEach((e=>{e.target.influence=i*(e.weight/100)})),this.materialValueBindingMergerMap[e]&&this.materialValueBindingMergerMap[e].morphing(i)}morphingPreset(e,t){if(!this.presetMorphTargetMap[e])return;const i=this.calcMorphValue(e,t);this.presetMorphTargetMap[e].forEach((e=>{e.target.influence=i*(e.weight/100)}))}calcMorphValue(e,t){const i=Math.max(0,Math.min(1,t));return this.isBinaryMorphMap[e]?i>.5?1:0:i}getMorphingList(){return Object.keys(this.morphTargetMap)}getFirstPersonCameraPosition(){const e=this.getFirstPersonBone();if(!e)return null;const t=e.getAbsolutePosition(),n=this.ext.firstPerson.firstPersonBoneOffset;return new i.Vector3(t.x+n.x,t.y+n.y,t.z+n.z)}getFirstPersonBone(){return this.findTransformNode(this.ext.firstPerson.firstPersonBone)}getBone(e){return this.transformNodeMap[e]||null}get humanoidBone(){return this._humanoidBone}get rootMesh(){return this._rootMesh}findTransformNode(e){return this.transformNodeCache[e]||null}findMesh(e){return this.meshCache[e]&&this.meshCache[e][0]||null}findMeshes(e){return this.meshCache[e]||null}constructIsBinaryMap(){this.ext.blendShapeMaster.blendShapeGroups.forEach((e=>{this.isBinaryMorphMap[e.name]=e.isBinary}))}constructMorphTargetMap(){this.ext.blendShapeMaster.blendShapeGroups.forEach((e=>{e.binds&&e.binds.forEach((t=>{const i=this.findMeshes(t.mesh);i?i.forEach((i=>{const n=i.morphTargetManager;if(!n)return void console.log("Undefined morphTargetManager",t);const r=n.getTarget(t.index);this.morphTargetMap[e.name]=this.morphTargetMap[e.name]||[],this.morphTargetMap[e.name].push({target:r,weight:t.weight}),e.presetName&&(this.presetMorphTargetMap[e.presetName]=this.presetMorphTargetMap[e.presetName]||[],this.presetMorphTargetMap[e.presetName].push({target:r,weight:t.weight}))})):console.log("Undefined BlendShapeBind Mesh",t)}))}))}constructMaterialValueBindingMergerMap(){const e=this.scene.materials.slice(this.materialsNodesFrom);this.ext.blendShapeMaster.blendShapeGroups.forEach((t=>{t.materialValues&&(this.materialValueBindingMergerMap[t.name]=new h(e,t.materialValues))}))}constructTransformNodeMap(){this.ext.humanoid.humanBones.forEach((e=>{const t=this.findTransformNode(e.node);t&&(this.transformNodeMap[e.bone]=t)}))}constructTransformNodeCache(){const e={};for(let t=this.transformNodesFrom;t<this.scene.transformNodes.length;t++){const i=this.scene.transformNodes[t];if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers)if(t.startsWith("/nodes/")){e[parseInt(t.substr(7),10)]=i;break}}return e}constructMeshCache(){const e={};for(let t=this.meshesFrom;t<this.scene.meshes.length;t++){const i=this.scene.meshes[t];if("__root__"!==i.id){if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers){const n=t.match(/^\/meshes\/(\d+).+$/);if(n){const t=parseInt(n[1],10);e[t]=e[t]||[],e[t].push(i);break}}}else this._rootMesh=i}return e}}class w{constructor(e){this.loader=e,this.name="VRM",this.enabled=!0,this.meshesFrom=0,this.transformNodesFrom=0,this.materialsFrom=0,this.meshesFrom=this.loader.babylonScene.meshes.length-1,this.transformNodesFrom=this.loader.babylonScene.transformNodes.length,this.materialsFrom=this.loader.babylonScene.materials.length}dispose(){this.loader=null}onReady(){if(!this.loader.gltf.extensions||!this.loader.gltf.extensions.VRM)return;const e=this.loader.babylonScene,t=new R(this.loader.gltf.extensions.VRM,this.loader.babylonScene,this.meshesFrom,this.transformNodesFrom,this.materialsFrom);e.metadata=e.metadata||{},e.metadata.vrmManagers=e.metadata.vrmManagers||[],e.metadata.vrmManagers.push(t),this.loader.babylonScene.onDisposeObservable.add((()=>{t.dispose(),this.loader.babylonScene.metadata.vrmManagers=[]}))}_loadVertexDataAsync(e,t,i){return t.extras&&t.extras.targetNames?(i.metadata=i.metadata||{},i.metadata.vrmTargetNames=t.extras.targetNames,null):null}_loadMaterialAsync(e,t,i,n,r){return new c(this.loader).generate(e,t,i,n,r)}}u.GLTFLoader.RegisterExtension("VRM",(e=>new w(e)));var F=C(6),X=C(746);class U extends X.GLTFFileLoader{constructor(){super(...arguments),this.name="vrm",this.extensions={".vrm":{isBinary:!0},".vci":{isBinary:!0}}}createPlugin(){return new U}}F.SceneLoader&&F.SceneLoader.RegisterPlugin(new U)})(),L})()));